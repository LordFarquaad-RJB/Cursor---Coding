/**
 * Live-SYS-ShopSystem - Built Version
 * 
 * Generated: 2025-07-04T12:21:25.883Z
 * Mode: Production
 * Build System: v2.0
 * 
 * This file contains all ShopSystem modules combined for Roll20 deployment.
 * Original files are located in the modules/ directory.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Make changes to the individual module files and rebuild.
 */

// ===================================================================
// SHOPSYSTEM MODULES - START
// ===================================================================


// ===================================================================
// MODULE 1/8: ShopConfig.js
// ===================================================================

/**
 * ShopConfig.js
 * 
 * Consolidated configuration module for the Shop System
 * Eliminates duplicate configuration scattered throughout the main file
 * 
 * Replaces:
 * - CONFIG object (Lines 1-400 in main file)
 * - Scattered emoji definitions
 * - Duplicate constants and defaults
 * 
 * Estimated savings: 150-200 lines
 */

const ShopConfig = {
    // System Information
    VERSION: '1.0.0',
    DEBUG: false,
    
    // Logging Configuration (consolidated from multiple locations)
    LOGGING: {
        ENABLED: true,
        LEVEL: "info",
        PREFIX: {
            info: 'üìú',
            error: '‚ùå',
            success: '‚úÖ',
            warning: '‚ö†Ô∏è',
            debug: 'üîç'
        }
    },
    
    // Handout Configuration
    HANDOUT: {
        DATABASE: "Item-Database",
        SHOP_PREFIX: "Shop-",
    },
    
    // Currency Configuration
    CURRENCY: {
        COPPER_PER_SILVER: 10,
        COPPER_PER_ELECTRUM: 50,
        COPPER_PER_GOLD: 100,
        COPPER_PER_PLATINUM: 1000,
        DEFAULT_FORMAT: "gp",
        SYMBOLS: {
            cp: "cp",
            sp: "sp", 
            ep: "ep",
            gp: "gp",
            pp: "pp"
        }
    },
    
    // Display Configuration
    DISPLAY: {
        ITEMS_PER_PAGE: 10,
        USE_ROLL_TEMPLATES: true,
        DEFAULT_TEMPLATE: "default",
        STOCK_DISPLAY_THRESHOLD: 30
    },
    
    // Pricing Configuration
    PRICING: {
        SELL_PRICE_MODIFIER: 0.5,
        HAGGLE_MAX_ADJUSTMENT: 0.2,
        MIN_PRICE_COPPER: 1
    },
    
    // Haggling Configuration
    HAGGLE: {
        BASE_DC: 15,
        ADVANTAGE_THRESHOLD: 5,
        DEFAULT_STORE_ATTEMPTS: 3,
        SKILLS: ["deception", "persuasion", "intimidation", "Sleight of Hand"]
    },
    
    // Item Configuration
    ITEM: {
        DEFAULT_CATEGORY: "equipment",
        DEFAULT_RARITY: "common",
        CATEGORIES: [
            "weapons", 
            "Armor & Attire", 
            "equipment", 
            "potions", 
            "scrolls", 
            "magic", 
            "Mounts & Vehicles", 
            "Services"
        ],
        RARITIES: ["common", "uncommon", "rare", "very rare", "legendary"]
    },
    
    // Consolidated Emoji Configuration (removed duplicates)
    EMOJI: {
        // Category Emojis
        CATEGORY: {
            weapons: "‚öîÔ∏è",
            "Armor & Attire": "üõ°Ô∏è",
            potions: "üß™",
            scrolls: "üìú",
            magic: "‚ú®",
            equipment: "üéí",
            "Mounts & Vehicles": "üê¥üõû",
            Services: "üõéÔ∏è"
        },
        
        // Rarity Emojis
        RARITY: {
            common: "‚ö™",
            uncommon: "üü¢",
            rare: "üîµ",
            "very rare": "üü£",
            legendary: "üü†"
        },
        
        // General UI Emojis
        UI: {
            shop: "üè™",
            basket: "üß∫",
            money: "üí∞",
            add: "‚ûï",
            remove: "‚ûñ",
            confirm: "‚úÖ",
            cancel: "‚ùå",
            help: "‚ùì",
            menu: "üìã"
        }
    },
    
    // Rarity Order (for sorting)
    RARITY_ORDER: {
        common: 0,
        uncommon: 1,
        rare: 2,
        "very rare": 3,
        legendary: 4
    },
    
    // Commands Configuration
    COMMANDS: {
        SHOP_PREFIX: "!shop",
        DB_PREFIX: "!itemdb",
        SUBCOMMANDS: {
            SHOP: ["open", "list", "add", "remove", "buy", "sell", "basket", "haggle"],
            DB: ["init", "import", "end", "list", "cancel", "add", "add_param", "add_save"]
        }
    },
    
    // Shop Settings
    SHOP_SETTINGS: {
        SHOP_TYPES: [
            "General Store", "Blacksmith", "Armorer", "Alchemist", 
            "Magic Shop", "Potion Shop", "Scroll Shop", "Tavern",
            "Jeweler", "Clothier", "Adventuring Supplies", "Exotic Goods"
        ],
        
        LOCATIONS: [
            {name: "Merchant District", itemCount: 40, rarityBonus: 10},
            {name: "City Center", itemCount: 30, rarityBonus: 5},
            {name: "Town", itemCount: 20, rarityBonus: 0},
            {name: "Village", itemCount: 15, rarityBonus: -5},
            {name: "Roadside", itemCount: 10, rarityBonus: -10},
            {name: "Traveling Merchant", itemCount: 8, rarityBonus: 0},
            {name: "Outpost", itemCount: 12, rarityBonus: -5},
            {name: "Dungeon Entrance", itemCount: 8, rarityBonus: 15},
            {name: "Festival", itemCount: 25, rarityBonus: 5},
            {name: "Harbor", itemCount: 20, rarityBonus: 10}
        ],
        
        MERCHANT_TYPES: [
            {name: "Honest", dcMod: -2, critSuccess: "Appreciates your fairness", critFailure: "Disappointed but understanding"},
            {name: "Greedy", dcMod: 3, critSuccess: "Reluctantly agrees", critFailure: "Throws you out"},
            {name: "Friendly", dcMod: -1, critSuccess: "Offers a bonus item", critFailure: "Looks sad but accepts"},
            {name: "Shrewd", dcMod: 2, critSuccess: "Impressed by your skills", critFailure: "Raises other prices"},
            {name: "Gullible", dcMod: -3, critSuccess: "Gives incredible discount", critFailure: "Doesn't realize they're losing money"},
            {name: "Suspicious", dcMod: 1, critSuccess: "Finally trusts you", critFailure: "Refuses to deal with you further"},
            {name: "Eccentric", dcMod: 0, critSuccess: "Gives you a strange bonus item", critFailure: "Changes the subject entirely"}
        ],
        
        DEFAULTS: {
            MERCHANT_NAME: "Unknown Merchant",
            SHOP_TYPE: "General Store",
            LOCATION: "Town",
            MERCHANT_TYPE: "Honest",
            BUY_MODIFIER: 1.0,
            SELL_MODIFIER: 0.5,
            DESCRIPTION: "A typical shop in a typical town.",
            WELCOME_MESSAGE: "Welcome to my shop! Take a look around.",
            MERCHANT_DESCRIPTION: "The merchant watches you browse their wares."
        }
    },
    
    // Stock Generation Configuration
    STOCK_GENERATION: {
        RARITY_CHANCES: {
            common: 70,
            uncommon: 20,
            rare: 8,
            "very rare": 1.5,
            legendary: 0.5
        },
        BASE_LEGENDARY_CHANCE: 5,
        DEFAULT_RANDOM_ITEMS: 10,
        DEFAULT_QUANTITY: {
            common: "3d6",
            uncommon: "2d4",
            rare: "1d4",
            "very rare": "1d2",
            legendary: "1d2-1"
        }
    },
    
    // Basket State Configuration
    BASKET_STATE: {
        MERGE_TIMEOUT: 3600000, // 1 hour in milliseconds
        ERROR_MESSAGES: {
            ALREADY_MERGED: "‚ùå Baskets are already merged.",
            NEED_BOTH_BASKETS: "‚ùå Need items in both buy and sell baskets to merge.",
            BASKETS_LOCKED: "‚ùå Cannot modify baskets while merged. Unmerge first.",
            NOT_MERGED: "‚ùå Baskets are not merged.",
            NO_BASKETS_TO_UNMERGE: "‚ùå No merged baskets to unmerge."
        }
    },
    
    // Helper Methods
    getCategoryEmoji(category) {
        return this.EMOJI.CATEGORY[category] || this.EMOJI.UI.menu;
    },
    
    getRarityEmoji(rarity) {
        return this.EMOJI.RARITY[rarity] || this.EMOJI.RARITY.common;
    },
    
    getShopTypeDefaults(shopType) {
        return this.SHOP_SETTINGS.DEFAULTS;
    },
    
    getLocationConfig(locationName) {
        return this.SHOP_SETTINGS.LOCATIONS.find(loc => loc.name === locationName) || 
               this.SHOP_SETTINGS.LOCATIONS.find(loc => loc.name === this.SHOP_SETTINGS.DEFAULTS.LOCATION);
    },
    
    getMerchantType(typeName) {
        return this.SHOP_SETTINGS.MERCHANT_TYPES.find(type => type.name === typeName) ||
               this.SHOP_SETTINGS.MERCHANT_TYPES.find(type => type.name === this.SHOP_SETTINGS.DEFAULTS.MERCHANT_TYPE);
    },
    
    validateCategory(category) {
        if (!category) return this.ITEM.DEFAULT_CATEGORY;
        const lowerCaseCategory = category.toLowerCase();
        const foundCategory = this.ITEM.CATEGORIES.find(
            cfgCategory => cfgCategory.toLowerCase() === lowerCaseCategory
        );
        return foundCategory || this.ITEM.DEFAULT_CATEGORY;
    },
    
    validateRarity(rarity) {
        if (!rarity) return this.ITEM.DEFAULT_RARITY;
        const normalized = rarity.toLowerCase().trim();
        
        // Handle special case for "very rare"
        if (normalized === "very" || normalized === "very_rare" || normalized === "very-rare") {
            return "very rare";
        }
        
        return this.ITEM.RARITIES.includes(normalized) ? normalized : this.ITEM.DEFAULT_RARITY;
    },
    
    // Get all valid categories for validation
    getValidCategories() {
        return [...this.ITEM.CATEGORIES, 'all'];
    },
    
    // Get all valid rarities for validation  
    getValidRarities() {
        return [...this.ITEM.RARITIES, 'all'];
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.ShopConfig = ShopConfig;
}

// END MODULE: ShopConfig.js


// ===================================================================
// MODULE 2/8: CurrencyManager.js
// ===================================================================

/**
 * CurrencyManager.js
 * 
 * Unified currency management module for the Shop System
 * Consolidates all currency operations and character sheet compatibility
 * 
 * Replaces:
 * - toCopper() function (Lines 500-520)
 * - fromCopper() function (Lines 520-580) 
 * - formatCurrency() function (Lines 580-600)
 * - getCharacterCurrency() function (Lines 850-1000)
 * - setCharacterCurrency() function (Lines 2100-2250)
 * 
 * Estimated savings: 200-300 lines
 */

const CurrencyManager = {
    // Reference to ShopConfig for currency constants
    config: null,
    
    // Initialize with config reference
    init(shopConfig) {
        this.config = shopConfig;
        return this;
    },
    
    /**
     * Convert any currency object to copper pieces
     * @param {Object|number} currency - Currency object or number
     * @returns {number} Total value in copper pieces
     */
    toCopper(currency) {
        if (typeof currency === 'number') {
            return currency;
        }
        
        if (!currency) return 0;
        
        const config = this.config?.CURRENCY || {
            COPPER_PER_SILVER: 10,
            COPPER_PER_ELECTRUM: 50,
            COPPER_PER_GOLD: 100,
            COPPER_PER_PLATINUM: 1000
        };
        
        let copper = 0;
        if (currency.cp) copper += currency.cp;
        if (currency.sp) copper += currency.sp * config.COPPER_PER_SILVER;
        if (currency.ep) copper += currency.ep * config.COPPER_PER_ELECTRUM;
        if (currency.gp) copper += currency.gp * config.COPPER_PER_GOLD;
        if (currency.pp) copper += currency.pp * config.COPPER_PER_PLATINUM;
        
        return copper;
    },
    
    /**
     * Convert copper pieces to currency object
     * @param {number} copper - Total copper pieces
     * @returns {Object} Currency object with appropriate denominations
     */
    fromCopper(copper) {
        if (!copper) return { cp: 0 };
        if (copper < 0) return { cp: 0 };
        
        const config = this.config?.CURRENCY || {
            COPPER_PER_SILVER: 10,
            COPPER_PER_ELECTRUM: 50,
            COPPER_PER_GOLD: 100,
            COPPER_PER_PLATINUM: 1000
        };
        
        // Use platinum format only if value is 1000 gp or more
        const goldThreshold = 1000 * config.COPPER_PER_GOLD;
        
        if (copper >= goldThreshold) {
            const currency = {
                pp: Math.floor(copper / config.COPPER_PER_PLATINUM)
            };
            
            copper %= config.COPPER_PER_PLATINUM;
            
            if (copper >= config.COPPER_PER_GOLD) {
                currency.gp = Math.floor(copper / config.COPPER_PER_GOLD);
                copper %= config.COPPER_PER_GOLD;
            }
            
            if (copper >= config.COPPER_PER_SILVER) {
                currency.sp = Math.floor(copper / config.COPPER_PER_SILVER);
                copper %= config.COPPER_PER_SILVER;
            }
            
            if (copper > 0) {
                currency.cp = copper;
            }
            
            return currency;
        }
        // For medium value items, use gold-based format
        else if (copper >= 100) {
            const currency = {
                gp: Math.floor(copper / config.COPPER_PER_GOLD)
            };
            
            copper %= config.COPPER_PER_GOLD;
            
            if (copper >= config.COPPER_PER_SILVER) {
                currency.sp = Math.floor(copper / config.COPPER_PER_SILVER);
                copper %= config.COPPER_PER_SILVER;
            }
            
            if (copper > 0) {
                currency.cp = copper;
            }
            
            return currency;
        }
        // For low value items
        else {
            const currency = {};
            
            if (copper >= config.COPPER_PER_SILVER) {
                currency.sp = Math.floor(copper / config.COPPER_PER_SILVER);
                copper %= config.COPPER_PER_SILVER;
            }
            
            if (copper > 0 || Object.keys(currency).length === 0) {
                currency.cp = copper;
            }
            
            return currency;
        }
    },
    
    /**
     * Format currency object as display string
     * @param {Object} currency - Currency object
     * @returns {string} Formatted currency string
     */
    formatCurrency(currency) {
        if (!currency) return "0 gp";
        
        let copperValue = this.toCopper(currency);
        if (copperValue === 0) return "0 gp";
        
        const formatted = this.fromCopper(copperValue);
        const parts = [];
        const symbols = this.config?.CURRENCY?.SYMBOLS || {
            pp: "pp", gp: "gp", ep: "ep", sp: "sp", cp: "cp"
        };
        
        if (formatted.pp) parts.push(`${formatted.pp}${symbols.pp}`);
        if (formatted.gp) parts.push(`${formatted.gp}${symbols.gp}`);
        if (formatted.ep) parts.push(`${formatted.ep}${symbols.ep}`);
        if (formatted.sp) parts.push(`${formatted.sp}${symbols.sp}`);
        if (formatted.cp) parts.push(`${formatted.cp}${symbols.cp}`);
        
        return parts.join(" ");
    },
    
    /**
     * Get character's current currency from character sheet
     * Handles multiple sheet types (Standard D&D 5e, Beacon, etc.)
     * @param {string} characterId - Character ID
     * @returns {Object} Currency object
     */
    getCharacterCurrency(characterId) {
        const currency = { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 };
        const char = getObj('character', characterId);
        if (!char) {
            this.log(`Character not found for ID: ${characterId}`, 'error');
            return currency;
        }

        const charName = char.get('name');
        this.log(`üí∞ Getting currency for ${charName} (ID: ${characterId})`, 'debug');

        // Check for Standard D&D 5e Sheet Attributes First
        const standardAttrs = ['pp', 'gp', 'ep', 'sp', 'cp'];
        let foundStandard = false;
        standardAttrs.forEach(coin => {
            const attrVal = getAttrByName(characterId, coin);
            if (attrVal !== undefined && attrVal !== null && attrVal !== "") {
                currency[coin] = parseInt(attrVal) || 0;
                if (currency[coin] > 0) foundStandard = true;
                this.log(` -> Found standard attribute ${coin}: ${currency[coin]}`, 'debug');
            }
        });

        if (foundStandard) {
            this.log(` -> Using standard attributes for ${charName}.`, 'debug');
            return currency;
        }

        // Check for Beacon Sheet Attributes (money_*)
        const beaconAttrs = {
            pp: 'money_pp',
            gp: 'money_gp',
            ep: 'money_ep',
            sp: 'money_sp',
            cp: 'money_cp'
        };
        let foundBeacon = false;
        Object.entries(beaconAttrs).forEach(([coin, attrName]) => {
            const attrVal = getAttrByName(characterId, attrName);
            if (attrVal !== undefined && attrVal !== null && attrVal !== "") {
                currency[coin] = parseInt(attrVal) || 0;
                if (currency[coin] > 0) foundBeacon = true;
                this.log(` -> Found Beacon attribute ${attrName}: ${currency[coin]}`, 'debug');
            }
        });

        if (foundBeacon) {
            this.log(` -> Using Beacon attributes for ${charName}.`, 'debug');
            return currency;
        }

        // Check for Beacon Sheet Store Attribute (Fallback)
        const storeAttr = findObjs({
            _type: 'attribute',
            _characterid: characterId,
            name: 'store'
        })[0];

        if (storeAttr) {
            this.log(` -> Found Beacon 'store' attribute for ${charName}. Attempting parse...`, 'debug');
            try {
                let storeData = storeAttr.get('current');
                if (typeof storeData === 'string') {
                    if (storeData.trim() === '') {
                        this.log(` -> Beacon 'store' attribute is empty for ${charName}.`, 'debug');
                        throw new Error("Store attribute is empty");
                    }
                    storeData = JSON.parse(storeData);
                }

                if (typeof storeData === 'object' && storeData !== null) {
                    const storeCurrencies = {};
                    
                    const searchForCurrency = (obj) => {
                        if (!obj) return;
                        if (Array.isArray(obj)) {
                            obj.forEach(item => searchForCurrency(item));
                        } else if (typeof obj === 'object') {
                            if (obj.name && obj.type === "Currency" && typeof obj.value === 'number') {
                                const coinName = obj.name.toLowerCase();
                                if (coinName === 'platinum') storeCurrencies.pp = obj.value;
                                else if (coinName === 'gold') storeCurrencies.gp = obj.value;
                                else if (coinName === 'electrum') storeCurrencies.ep = obj.value;
                                else if (coinName === 'silver') storeCurrencies.sp = obj.value;
                                else if (coinName === 'copper') storeCurrencies.cp = obj.value;
                            }
                            Object.values(obj).forEach(value => searchForCurrency(value));
                        }
                    };
                    searchForCurrency(storeData);

                    let foundInStore = false;
                    if (storeCurrencies.pp !== undefined) { currency.pp = storeCurrencies.pp; foundInStore = true; }
                    if (storeCurrencies.gp !== undefined) { currency.gp = storeCurrencies.gp; foundInStore = true; }
                    if (storeCurrencies.ep !== undefined) { currency.ep = storeCurrencies.ep; foundInStore = true; }
                    if (storeCurrencies.sp !== undefined) { currency.sp = storeCurrencies.sp; foundInStore = true; }
                    if (storeCurrencies.cp !== undefined) { currency.cp = storeCurrencies.cp; foundInStore = true; }

                    if (foundInStore) {
                        this.log(` -> Using Beacon 'store' attribute for ${charName}.`, 'debug');
                        return currency;
                    } else {
                        this.log(` -> No currency found within Beacon 'store' attribute for ${charName}.`, 'debug');
                    }
                }
            } catch (e) {
                this.log(` -> Error parsing Beacon 'store' attribute for ${charName}: ${e.message}`, 'warn');
            }
        }

        this.log(` -> No standard or Beacon currency attributes found for ${charName}. Returning zeroed currency.`, 'warn');
        return { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 };
    },
    
    /**
     * Set character's currency on character sheet
     * Handles multiple sheet types (Standard D&D 5e, Beacon, etc.)
     * @param {string} characterId - Character ID
     * @param {Object} newCurrency - New currency values
     * @returns {boolean} Success status
     */
    setCharacterCurrency(characterId, newCurrency) {
        const char = getObj('character', characterId);
        if (!char) {
            this.log(`Character not found for ID: ${characterId} when trying to set currency`, 'error');
            return false;
        }

        const charName = char.get('name');
        this.log(`üí∞ Setting currency for ${charName} (ID: ${characterId}) to: ` +
                 `${newCurrency.pp || 0}pp, ${newCurrency.gp || 0}gp, ${newCurrency.ep || 0}ep, ${newCurrency.sp || 0}sp, ${newCurrency.cp || 0}cp`, 'debug');

        let attributeUpdated = false;

        // Helper to set attribute value
        const setAttribute = (attrName, value) => {
            let attr = findObjs({ _type: 'attribute', _characterid: characterId, name: attrName })[0];
            if (attr) {
                attr.set('current', value);
                this.log(` -> Updated attribute ${attrName} to ${value}`, 'debug');
                attributeUpdated = true;
                return true;
            } else {
                this.log(` -> Attribute ${attrName} not found, could not update.`, 'debug');
                return false;
            }
        };

        // Attempt to update Standard D&D 5e Sheet Attributes
        const standardAttrs = ['pp', 'gp', 'ep', 'sp', 'cp'];
        let foundStandard = false;
        standardAttrs.forEach(coin => {
            const attrExists = findObjs({ _type: 'attribute', _characterid: characterId, name: coin })[0];
            if (attrExists) {
                foundStandard = true;
                setAttribute(coin, newCurrency[coin] || 0);
            }
        });

        if (foundStandard && attributeUpdated) {
            this.log(` -> Updated standard attributes for ${charName}.`, 'debug');
            return true;
        } else if (foundStandard && !attributeUpdated) {
            this.log(` -> Found standard attributes for ${charName}, but failed to update them.`, 'warn');
        }

        // Attempt to update Beacon Sheet Attributes (money_*)
        const beaconAttrs = {
            pp: 'money_pp',
            gp: 'money_gp',
            ep: 'money_ep',
            sp: 'money_sp',
            cp: 'money_cp'
        };
        let foundBeacon = false;
        attributeUpdated = false;
        Object.entries(beaconAttrs).forEach(([coin, attrName]) => {
            const attrExists = findObjs({ _type: 'attribute', _characterid: characterId, name: attrName })[0];
            if (attrExists) {
                foundBeacon = true;
                setAttribute(attrName, newCurrency[coin] || 0);
            }
        });

        if (foundBeacon && attributeUpdated) {
            this.log(` -> Updated Beacon attributes for ${charName}.`, 'debug');
            return true;
        } else if (foundBeacon && !attributeUpdated) {
            this.log(` -> Found Beacon attributes for ${charName}, but failed to update them.`, 'warn');
        }

        // Fallback: Could not find any known currency attributes
        if (!foundStandard && !foundBeacon) {
            this.log(` -> Could not find any known currency attributes to update for ${charName}.`, 'error');
        } else if (!attributeUpdated) {
            this.log(` -> Found currency attributes but failed to update them for ${charName}.`, 'error');
        }

        return attributeUpdated;
    },
    
    /**
     * Calculate total value of items array
     * @param {Array} items - Array of items with price and quantity
     * @returns {Object} Total currency object
     */
    calculateTotal(items) {
        let totalCopper = 0;
        
        items.forEach(item => {
            const itemPrice = this.toCopper(item.price);
            const quantity = item.quantity || 1;
            totalCopper += itemPrice * quantity;
        });
        
        return this.fromCopper(totalCopper);
    },
    
    /**
     * Apply price modifier to currency amount
     * @param {Object} price - Original price
     * @param {number} modifier - Modifier (e.g., 0.5 for half price, 1.2 for 20% markup)
     * @returns {Object} Modified price
     */
    applyModifier(price, modifier) {
        const copperValue = this.toCopper(price);
        const modifiedCopper = Math.max(1, Math.round(copperValue * modifier));
        return this.fromCopper(modifiedCopper);
    },
    
    /**
     * Check if player can afford a purchase
     * @param {Object} playerCurrency - Player's current currency
     * @param {Object} cost - Cost of purchase
     * @returns {boolean} Whether player can afford it
     */
    canAfford(playerCurrency, cost) {
        const playerCopper = this.toCopper(playerCurrency);
        const costCopper = this.toCopper(cost);
        return playerCopper >= costCopper;
    },
    
    /**
     * Subtract cost from player currency
     * @param {Object} playerCurrency - Player's current currency
     * @param {Object} cost - Cost to subtract
     * @returns {Object} Remaining currency
     */
    subtractCost(playerCurrency, cost) {
        const playerCopper = this.toCopper(playerCurrency);
        const costCopper = this.toCopper(cost);
        const remainingCopper = Math.max(0, playerCopper - costCopper);
        return this.fromCopper(remainingCopper);
    },
    
    /**
     * Add currency to existing amount
     * @param {Object} existing - Existing currency
     * @param {Object} addition - Currency to add
     * @returns {Object} Combined currency
     */
    addCurrency(existing, addition) {
        const existingCopper = this.toCopper(existing);
        const additionCopper = this.toCopper(addition);
        return this.fromCopper(existingCopper + additionCopper);
    },
    
    // Logging helper (uses ShopConfig if available)
    log(message, type = 'info') {
        const prefix = this.config?.LOGGING?.PREFIX?.[type] || 'üìú';
        log(`${prefix} CurrencyManager: ${message}`);
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.CurrencyManager = CurrencyManager;
}

// END MODULE: CurrencyManager.js


// ===================================================================
// MODULE 3/8: MenuBuilder.js
// ===================================================================

/**
 * MenuBuilder.js
 * 
 * Template-based menu generation system for the Shop System
 * Consolidates all repetitive menu generation patterns
 * 
 * Replaces:
 * - 15+ similar menu generation functions (Lines 3000-4000)
 * - Repeated menu template patterns
 * - Duplicate button generation logic
 * - Similar navigation patterns
 * 
 * Estimated savings: 200-300 lines
 */

const MenuBuilder = {
    // Reference to ShopConfig for emojis and constants
    config: null,
    
    // Initialize with config reference
    init(shopConfig) {
        this.config = shopConfig;
        return this;
    },
    
    /**
     * Create a basic menu structure
     * @param {string} title - Menu title
     * @param {Object} sections - Menu sections object
     * @param {Object} options - Additional options
     * @returns {string} Complete menu string
     */
    createMenu(title, sections = {}, options = {}) {
        const menu = [];
        
        // Start with template
        menu.push("&{template:default}");
        
        // Add title
        if (title) {
            const titleEmoji = options.titleEmoji || this.getUIEmoji('menu');
            menu.push(`{{name=${titleEmoji} ${title}}}`);
        }
        
        // Add sections
        Object.entries(sections).forEach(([sectionTitle, content]) => {
            if (content && content.trim()) {
                menu.push(`{{${sectionTitle}=${content}}}`);
            }
        });
        
        return menu.join(" ");
    },
    
    /**
     * Create a menu section with buttons
     * @param {Array} buttons - Array of button objects or strings
     * @param {Object} options - Formatting options
     * @returns {string} Formatted section content
     */
    createButtonSection(buttons, options = {}) {
        if (!buttons || buttons.length === 0) return "";
        
        const formattedButtons = buttons.map(button => {
            if (typeof button === 'string') {
                return button;
            }
            
            return this.createButton(button.text, button.command, button.options);
        });
        
        const separator = options.separator || ' ';
        const lineBreak = options.lineBreak || '<br>';
        
        if (options.columns && options.columns > 1) {
            // Arrange in columns
            const rows = [];
            for (let i = 0; i < formattedButtons.length; i += options.columns) {
                const row = formattedButtons.slice(i, i + options.columns);
                rows.push(row.join(separator));
            }
            return rows.join(lineBreak);
        }
        
        return formattedButtons.join(separator);
    },
    
    /**
     * Create a button with command
     * @param {string} text - Button text
     * @param {string} command - Button command
     * @param {Object} options - Button options
     * @returns {string} Formatted button
     */
    createButton(text, command, options = {}) {
        if (!text || !command) return "";
        
        const emoji = options.emoji || "";
        const fullText = emoji ? `${emoji} ${text}` : text;
        
        return `[${fullText}](${command})`;
    },
    
    /**
     * Create navigation section with common back/help buttons
     * @param {Array} navButtons - Custom navigation buttons
     * @param {Object} options - Navigation options
     * @returns {string} Navigation section content
     */
    createNavigation(navButtons = [], options = {}) {
        const defaultButtons = [];
        
        if (options.showBack && options.backCommand) {
            defaultButtons.push({
                text: options.backText || "Back",
                command: options.backCommand,
                options: { emoji: "üîô" }
            });
        }
        
        if (options.showHelp && options.helpCommand) {
            defaultButtons.push({
                text: options.helpText || "Help", 
                command: options.helpCommand,
                options: { emoji: this.getUIEmoji('help') }
            });
        }
        
        const allButtons = [...navButtons, ...defaultButtons];
        return this.createButtonSection(allButtons, { separator: ' ' });
    },
    
    /**
     * Create a shop menu with standard sections
     * @param {Object} shop - Shop data
     * @param {boolean} isGM - Whether viewing as GM
     * @param {Object} options - Menu options
     * @returns {string} Complete shop menu
     */
    buildShopMenu(shop, isGM = false, options = {}) {
        const sections = {};
        
        // Basic shop info
        if (shop.merchant_name) {
            sections.Merchant = shop.merchant_name;
        }
        
        if (shop.description) {
            sections.Description = shop.description;
        }
        
        if (shop.welcome_message && !isGM) {
            sections.Welcome = shop.welcome_message;
        }
        
        if (shop.special_event?.type && shop.special_event.type !== "None") {
            sections["Special Event"] = `${shop.special_event.type}: ${shop.special_event.details}`;
        }
        
        // Categories section
        const categoryButtons = this.buildCategoryButtons(options.categories || []);
        if (categoryButtons) {
            sections.Categories = categoryButtons;
        }
        
        // Actions section
        const actionButtons = this.buildShopActionButtons(isGM, options.shopName);
        if (actionButtons) {
            sections.Actions = actionButtons;
        }
        
        // Navigation
        const navigation = this.createNavigation([], {
            showHelp: true,
            helpCommand: "!shop help",
            showBack: options.showBackToList,
            backCommand: "!shop list",
            backText: "Shop List"
        });
        
        if (navigation) {
            sections.Navigation = navigation;
        }
        
        const title = isGM ? `${shop.name} (GM View)` : shop.name;
        const titleEmoji = this.config?.getCategoryEmoji('shop') || 'üè™';
        
        return this.createMenu(title, sections, { titleEmoji });
    },
    
    /**
     * Build category browsing buttons
     * @param {Array} categories - Available categories
     * @returns {string} Category button section
     */
    buildCategoryButtons(categories = []) {
        if (categories.length === 0) {
            // Use default categories
            categories = this.config?.ITEM?.CATEGORIES || ['weapons', 'equipment', 'potions'];
        }
        
        const buttons = [];
        
        // Add "All Items" button first
        buttons.push({
            text: "All Items",
            command: "!shop browse all",
            options: { emoji: "üì¶" }
        });
        
        // Add category buttons
        categories.forEach(category => {
            const emoji = this.getCategoryEmoji(category);
            buttons.push({
                text: category,
                command: `!shop browse ${category}`,
                options: { emoji }
            });
        });
        
        return this.createButtonSection(buttons, { columns: 2, lineBreak: '\n' });
    },
    
    /**
     * Build shop action buttons
     * @param {boolean} isGM - Whether viewing as GM
     * @param {string} shopName - Shop name for commands
     * @returns {string} Action button section
     */
    buildShopActionButtons(isGM, shopName = "") {
        const buttons = [];
        
        if (isGM) {
            // GM actions
            buttons.push(
                { text: "Manage Stock", command: `!shop stock`, options: { emoji: "üì¶" } },
                { text: "Edit Shop", command: `!shop edit ${shopName}`, options: { emoji: "‚öôÔ∏è" } },
                { text: "Generate Stock", command: `!shop stock random`, options: { emoji: "üé≤" } }
            );
        } else {
            // Player actions
            buttons.push(
                { text: "View Basket", command: "!shop basket view", options: { emoji: this.getUIEmoji('basket') } },
                { text: "Sell Items", command: "!shop sell", options: { emoji: "üí∞" } }
            );
        }
        
        return this.createButtonSection(buttons, { separator: ' ' });
    },
    
    /**
     * Build help menu with sections
     * @param {string} system - System name (shop, database, etc.)
     * @param {Object} helpSections - Help content sections
     * @param {boolean} isGM - Whether viewing as GM
     * @returns {string} Complete help menu
     */
    buildHelpMenu(system, helpSections = {}, isGM = false) {
        const sections = {};
        
        // Add system-specific sections
        Object.entries(helpSections).forEach(([title, content]) => {
            sections[title] = content;
        });
        
        // Add navigation
        const navButtons = [];
        
        if (system === 'shop') {
            navButtons.push({
                text: "Back to Shop",
                command: "!shop",
                options: { emoji: "üîô" }
            });
        } else if (system === 'database') {
            navButtons.push({
                text: "Database Commands",
                command: "!itemdb",
                options: { emoji: "üîô" }
            });
        }
        
        const navigation = this.createButtonSection(navButtons);
        if (navigation) {
            sections.Navigation = navigation;
        }
        
        const title = `${system.charAt(0).toUpperCase() + system.slice(1)} Help${isGM ? ' (GM)' : ''}`;
        
        return this.createMenu(title, sections, { titleEmoji: this.getUIEmoji('help') });
    },
    
    /**
     * Create item list display
     * @param {Array} items - Items to display
     * @param {Object} options - Display options
     * @returns {string} Formatted item list
     */
    buildItemList(items, options = {}) {
        if (!items || items.length === 0) {
            return "No items found.";
        }
        
        const maxItems = options.maxItems || 10;
        const displayItems = items.slice(0, maxItems);
        const showPrices = options.showPrices !== false;
        const showQuantity = options.showQuantity || false;
        const showRarity = options.showRarity || false;
        
        const itemLines = displayItems.map((item, index) => {
            let line = `${index + 1}. `;
            
            // Add rarity emoji if configured
            if (showRarity && item.rarity) {
                const rarityEmoji = this.getRarityEmoji(item.rarity);
                line += `${rarityEmoji} `;
            }
            
            // Add item name
            line += item.name;
            
            // Add quantity if available
            if (showQuantity && item.quantity) {
                line += ` (x${item.quantity})`;
            }
            
            // Add price if configured
            if (showPrices && item.price) {
                // Note: This would use CurrencyManager.formatCurrency in full implementation
                line += ` - ${this.formatPrice(item.price)}`;
            }
            
            // Add action buttons if specified
            if (options.addToBasket) {
                line += ` [Add](!shop basket add ${item.id})`;
            }
            
            return line;
        });
        
        let result = itemLines.join('\n');
        
        if (items.length > maxItems) {
            result += `\n... and ${items.length - maxItems} more items`;
        }
        
        return result;
    },
    
    /**
     * Create confirmation dialog
     * @param {string} title - Dialog title
     * @param {string} message - Confirmation message
     * @param {string} confirmCommand - Command for confirm button
     * @param {string} cancelCommand - Command for cancel button
     * @param {Object} options - Dialog options
     * @returns {string} Confirmation dialog menu
     */
    buildConfirmationDialog(title, message, confirmCommand, cancelCommand, options = {}) {
        const sections = {
            Message: message
        };
        
        const buttons = [
            {
                text: options.confirmText || "Confirm",
                command: confirmCommand,
                options: { emoji: this.getUIEmoji('confirm') }
            },
            {
                text: options.cancelText || "Cancel", 
                command: cancelCommand,
                options: { emoji: this.getUIEmoji('cancel') }
            }
        ];
        
        sections.Actions = this.createButtonSection(buttons, { separator: ' | ' });
        
        return this.createMenu(title, sections, { titleEmoji: options.titleEmoji });
    },
    
    // Helper methods for emojis (with fallbacks if config not available)
    getCategoryEmoji(category) {
        return this.config?.getCategoryEmoji?.(category) || "üì¶";
    },
    
    getRarityEmoji(rarity) {
        return this.config?.getRarityEmoji?.(rarity) || "‚ö™";
    },
    
    getUIEmoji(type) {
        return this.config?.EMOJI?.UI?.[type] || "üìã";
    },
    
    // Simple price formatting (would delegate to CurrencyManager in full implementation)
    formatPrice(price) {
        if (typeof price === 'object' && price.gp) {
            return `${price.gp}gp`;
        }
        return price.toString();
    },
    
    // Utility method to send menu to chat
    sendMenu(menuString, playerId = null, systemName = "ShopSystem") {
        if (playerId) {
            const player = getObj('player', playerId);
            if (player) {
                sendChat(systemName, `/w "${player.get('_displayname')}" ${menuString}`);
            } else {
                sendChat(systemName, `/w gm ${menuString}`);
            }
        } else {
            sendChat(systemName, `/w gm ${menuString}`);
        }
    },
    
    // Logging helper
    log(message, type = 'info') {
        const prefix = this.config?.LOGGING?.PREFIX?.[type] || 'üìú';
        log(`${prefix} MenuBuilder: ${message}`);
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.MenuBuilder = MenuBuilder;
}

// END MODULE: MenuBuilder.js


// ===================================================================
// MODULE 4/8: BasketManager.js
// ===================================================================

/**
 * BasketManager.js
 * 
 * Unified basket management module for the Shop System
 * Consolidates all shopping basket operations for both buying and selling
 * 
 * Replaces:
 * - Buy basket functions (Lines 7500-8000+)
 * - Sell basket functions (Lines 7500-8000+)
 * - Basket state management and merging logic
 * - Basket checkout and transaction handling
 * - Character association with baskets
 * 
 * Estimated savings: 300-400 lines
 */

const BasketManager = {
    // Reference to ShopConfig for configuration
    config: null,
    
    // Initialize with config reference
    init(shopConfig) {
        this.config = shopConfig;
        this.initializeBasketState();
        return this;
    },
    
    /**
     * Initialize basket state structure
     */
    initializeBasketState() {
        if (!state.ShopSystem) {
            state.ShopSystem = {};
        }
        
        if (!state.ShopSystem.playerBaskets) {
            state.ShopSystem.playerBaskets = {};
        }
        
        if (!state.ShopSystem.sellBaskets) {
            state.ShopSystem.sellBaskets = {};
        }
        
        if (!state.ShopSystem.sellBasketCharacter) {
            state.ShopSystem.sellBasketCharacter = {};
        }
        
        if (!state.ShopSystem.basketMergeState) {
            state.ShopSystem.basketMergeState = {};
        }
    },
    
    // ===================================================================
    // BUY BASKET OPERATIONS
    // ===================================================================
    
    /**
     * Add item to buy basket
     * @param {string} playerId - Player ID
     * @param {string} itemId - Item ID to add
     * @param {number} quantity - Quantity to add
     */
    addToBuyBasket(playerId, itemId, quantity = 1) {
        // Check if baskets are merged
        if (this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.BASKETS_LOCKED || "‚ùå Cannot modify baskets while merged.", playerId);
            return;
        }
        
        if (!ShopSystem.state.activeShop) {
            this.sendMessage("‚ùå No active shop selected", playerId);
            return;
        }
        
        const shop = ShopSystem.state.activeShop;
        
        // Find the item in shop inventory
        let foundItem = null;
        let itemCategory = '';
        
        for (const [category, items] of Object.entries(shop.inventory || {})) {
            if (Array.isArray(items)) {
                const item = items.find(i => i.id === itemId);
                if (item) {
                    foundItem = item;
                    itemCategory = category;
                    break;
                }
            }
        }
        
        if (!foundItem) {
            this.sendMessage("‚ùå Item not found in shop", playerId);
            return;
        }
        
        // Check availability
        if (foundItem.quantity < quantity) {
            this.sendMessage(`‚ùå Not enough in stock. Available: ${foundItem.quantity}`, playerId);
            return;
        }
        
        // Initialize player basket if needed
        if (!state.ShopSystem.playerBaskets[playerId]) {
            state.ShopSystem.playerBaskets[playerId] = [];
        }
        
        // Check if item already in basket
        const existingItemIndex = state.ShopSystem.playerBaskets[playerId].findIndex(item => item.id === itemId);
        
        if (existingItemIndex !== -1) {
            // Update existing item
            const existingItem = state.ShopSystem.playerBaskets[playerId][existingItemIndex];
            const newQuantity = existingItem.quantity + quantity;
            
            if (newQuantity > foundItem.quantity) {
                this.sendMessage(`‚ùå Cannot add more than available. Total would be ${newQuantity}, but only ${foundItem.quantity} available.`, playerId);
                return;
            }
            
            existingItem.quantity = newQuantity;
        } else {
            // Add new item to basket
            state.ShopSystem.playerBaskets[playerId].push({
                id: foundItem.id,
                name: foundItem.name,
                price: foundItem.price,
                quantity: quantity,
                category: itemCategory,
                rarity: foundItem.rarity || 'common'
            });
        }
        
        this.sendMessage(`‚úÖ Added ${quantity} ${foundItem.name} to your basket`, playerId);
        this.saveBasketState();
    },
    
    /**
     * Remove item from buy basket
     * @param {string} playerId - Player ID  
     * @param {number} index - Index of item to remove
     */
    removeFromBuyBasket(playerId, index) {
        // Check if baskets are merged
        if (this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.BASKETS_LOCKED || "‚ùå Cannot modify baskets while merged.", playerId);
            return;
        }
        
        if (!state.ShopSystem.playerBaskets[playerId] || 
            index >= state.ShopSystem.playerBaskets[playerId].length || 
            index < 0) {
            this.sendMessage('‚ùå Item not found in your basket!', playerId);
            return;
        }
        
        const removedItem = state.ShopSystem.playerBaskets[playerId][index];
        state.ShopSystem.playerBaskets[playerId].splice(index, 1);
        
        this.sendMessage(`‚úÖ Removed ${removedItem.name} from your basket`, playerId);
        this.saveBasketState();
        this.viewBuyBasket(playerId);
    },
    
    /**
     * View buy basket contents
     * @param {string} playerId - Player ID
     */
    viewBuyBasket(playerId) {
        if (!state.ShopSystem.playerBaskets[playerId] || 
            state.ShopSystem.playerBaskets[playerId].length === 0) {
            this.sendMessage('üß∫ Your basket is empty!', playerId);
            return;
        }
        
        const basket = state.ShopSystem.playerBaskets[playerId];
        const totalPrice = this.calculateBasketTotal(basket);
        
        // Create basket content display
        const itemsList = basket.map((item, index) => {
            const qtyStr = item.quantity > 1 ? ` (x${item.quantity})` : '';
            const itemTotal = ShopSystemModules.currency.toCopper(item.price) * item.quantity;
            const formattedTotal = ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(itemTotal));
            
            return `‚Ä¢ ${item.name}${qtyStr} - ${ShopSystemModules.currency.formatCurrency(item.price)} each = ${formattedTotal}\n` +
                   `   [‚ùå Remove](!shop basket remove ${index})`;
        }).join('\n');
        
        // Check if merging is possible
        const canMerge = this.canMergeBaskets(playerId);
        
        let menu = ShopSystemModules.menu.createMenu("üß∫ Shopping Basket", {
            "Items": itemsList,
            "Total Cost": `üí∞${ShopSystemModules.currency.formatCurrency(totalPrice)}`,
            "Actions": this.buildBuyBasketActions(playerId, canMerge)
        });
        
        this.sendMessage(menu, playerId);
    },
    
    /**
     * Clear buy basket
     * @param {string} playerId - Player ID
     */
    clearBuyBasket(playerId) {
        if (!state.ShopSystem.playerBaskets[playerId] || 
            state.ShopSystem.playerBaskets[playerId].length === 0) {
            this.sendMessage('‚ùå Your basket is already empty!', playerId);
            return;
        }
        
        state.ShopSystem.playerBaskets[playerId] = [];
        this.clearHaggleResults(playerId);
        this.saveBasketState();
        
        this.sendMessage('‚úÖ Your basket has been cleared', playerId);
    },
    
    // ===================================================================
    // SELL BASKET OPERATIONS
    // ===================================================================
    
    /**
     * Add item to sell basket
     * @param {string} playerId - Player ID
     * @param {string} itemPath - Item path/ID
     * @param {number} quantity - Quantity to add
     */
    addToSellBasket(playerId, itemPath, quantity = 1) {
        // Check if baskets are merged
        if (this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.BASKETS_LOCKED || "‚ùå Cannot modify baskets while merged.", playerId);
            return;
        }
        
        if (!ShopSystem.state.activeShop) {
            this.sendMessage('‚ùå No active shop!', playerId);
            return;
        }
        
        // Initialize sell basket if needed
        if (!state.ShopSystem.sellBaskets[playerId]) {
            state.ShopSystem.sellBaskets[playerId] = [];
        }
        
        // Get character ID from state
        const characterId = state.ShopSystem.sellBasketCharacter?.[playerId];
        
        if (!characterId) {
            this.sendMessage('‚ùå Character not identified for sell basket. Please use "!shop sell from [character]" first.', playerId);
            return;
        }
        
        const character = getObj('character', characterId);
        if (!character) {
            this.sendMessage('‚ùå Character not found', playerId);
            return;
        }
        
        // Extract inventory and process item
        this.processInventoryForSell(characterId, playerId, itemPath, quantity);
    },
    
    /**
     * Process character inventory for selling
     * @param {string} characterId - Character ID
     * @param {string} playerId - Player ID
     * @param {string} itemPath - Item path
     * @param {number} quantity - Quantity to sell
     */
    async processInventoryForSell(characterId, playerId, itemPath, quantity) {
        try {
            // This would integrate with the existing inventory extraction logic
            const result = await ShopSystem.shop.SELL_LOG_ExtractInventory(characterId, playerId);
            const { items } = result;
            
            const foundItem = items.find(item => item.id === itemPath);
            
            if (!foundItem) {
                this.sendMessage('‚ùå Item not found in inventory!', playerId);
                return;
            }
            
            const availableQty = foundItem.quantity || 1;
            quantity = Math.min(quantity, availableQty);
            
            if (quantity <= 0) {
                this.sendMessage('‚ùå Invalid quantity', playerId);
                return;
            }
            
            // Check if item already in basket
            const existingItemIndex = state.ShopSystem.sellBaskets[playerId].findIndex(item => item.id === itemPath);
            
            // Calculate sell price
            const shop = ShopSystem.state.activeShop;
            const sellModifier = shop.price_modifiers?.sell || this.config?.PRICING?.SELL_PRICE_MODIFIER || 0.5;
            
            let sellPrice = { gp: 0 };
            if (foundItem.price) {
                const itemCopper = ShopSystemModules.currency.toCopper(foundItem.price);
                const sellCopper = Math.floor(itemCopper * sellModifier);
                sellPrice = ShopSystemModules.currency.fromCopper(sellCopper);
            }
            
            if (existingItemIndex !== -1) {
                // Update existing item
                const currentQty = state.ShopSystem.sellBaskets[playerId][existingItemIndex].quantity;
                const newQty = currentQty + quantity;
                
                if (newQty > availableQty) {
                    this.sendMessage(`‚ùå Cannot add more than available in inventory (${availableQty})`, playerId);
                    return;
                }
                
                state.ShopSystem.sellBaskets[playerId][existingItemIndex].quantity = newQty;
            } else {
                // Add new item to basket
                state.ShopSystem.sellBaskets[playerId].push({
                    id: foundItem.id,
                    name: foundItem.name,
                    type: foundItem.type || "Item",
                    description: foundItem.description || "",
                    quantity: quantity,
                    price: sellPrice,
                    baseValue: foundItem.price,
                    data: foundItem.data,
                    category: foundItem.category,
                    rarity: foundItem.rarity || 'common',
                    characterId: characterId
                });
            }
            
            // Track character association
            state.ShopSystem.sellBasketCharacter[playerId] = characterId;
            
            this.sendMessage(`‚úÖ Added ${quantity} ${foundItem.name} to your sell basket`, playerId);
            this.viewSellBasket(playerId);
            
        } catch (error) {
            this.log(`Error adding to sell basket: ${error.message}`, 'error');
            this.sendMessage(`‚ùå Error adding to sell basket: ${error.message}`, playerId);
        }
    },
    
    /**
     * Remove item from sell basket
     * @param {string} playerId - Player ID
     * @param {number} index - Index of item to remove
     */
    removeFromSellBasket(playerId, index) {
        // Check if baskets are merged
        if (this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.BASKETS_LOCKED || "‚ùå Cannot modify baskets while merged.", playerId);
            return;
        }
        
        if (!state.ShopSystem.sellBaskets[playerId] || 
            index >= state.ShopSystem.sellBaskets[playerId].length || 
            index < 0) {
            this.sendMessage('‚ùå Item not found in your sell basket!', playerId);
            return;
        }
        
        const removedItem = state.ShopSystem.sellBaskets[playerId][index];
        state.ShopSystem.sellBaskets[playerId].splice(index, 1);
        
        this.sendMessage(`‚úÖ Removed ${removedItem.name} from your sell basket`, playerId);
        this.viewSellBasket(playerId);
    },
    
    /**
     * View sell basket contents
     * @param {string} playerId - Player ID
     */
    viewSellBasket(playerId) {
        if (!state.ShopSystem.sellBaskets[playerId] || 
            state.ShopSystem.sellBaskets[playerId].length === 0) {
            this.sendMessage('üì≠ Your sell basket is empty!', playerId);
            return;
        }
        
        const basket = state.ShopSystem.sellBaskets[playerId];
        const totalPrice = this.calculateBasketTotal(basket);
        
        // Create basket content display
        const itemsList = basket.map((item, index) => {
            const qtyStr = item.quantity > 1 ? ` (x${item.quantity})` : '';
            return `‚Ä¢ ${item.name}${qtyStr} - ${ShopSystemModules.currency.formatCurrency(item.price)} each\n` +
                   `   [‚ùå Remove](!shop sell remove ${index})`;
        }).join('\n');
        
        // Get character info
        let characterSection = "";
        if (state.ShopSystem.sellBasketCharacter?.[playerId]) {
            const characterId = state.ShopSystem.sellBasketCharacter[playerId];
            const character = getObj('character', characterId);
            if (character) {
                characterSection = character.get('name');
            }
        }
        
        const canMerge = this.canMergeBaskets(playerId);
        
        const sections = {
            "Items": itemsList,
            "Total Value": `üí∞${ShopSystemModules.currency.formatCurrency(totalPrice)}`,
            "Actions": this.buildSellBasketActions(playerId, canMerge)
        };
        
        if (characterSection) {
            sections["Character"] = characterSection;
        }
        
        const menu = ShopSystemModules.menu.createMenu("üß∫ Items to Sell", sections);
        this.sendMessage(menu, playerId);
    },
    
    /**
     * Clear sell basket
     * @param {string} playerId - Player ID
     */
    clearSellBasket(playerId) {
        if (!state.ShopSystem.sellBaskets[playerId] || 
            state.ShopSystem.sellBaskets[playerId].length === 0) {
            this.sendMessage('‚ùå Your sell basket is already empty!', playerId);
            return;
        }
        
        state.ShopSystem.sellBaskets[playerId] = [];
        this.clearHaggleResults(playerId);
        
        // Clear character tracking
        if (state.ShopSystem.sellBasketCharacter?.[playerId]) {
            delete state.ShopSystem.sellBasketCharacter[playerId];
        }
        
        this.sendMessage('‚úÖ Your sell basket has been cleared', playerId);
    },
    
    // ===================================================================
    // BASKET MERGING OPERATIONS
    // ===================================================================
    
    /**
     * Check if baskets can be merged
     * @param {string} playerId - Player ID
     * @returns {boolean} Whether baskets can be merged
     */
    canMergeBaskets(playerId) {
        const hasBuyItems = state.ShopSystem.playerBaskets[playerId] && state.ShopSystem.playerBaskets[playerId].length > 0;
        const hasSellItems = state.ShopSystem.sellBaskets?.[playerId] && state.ShopSystem.sellBaskets[playerId].length > 0;
        const isNotMerged = !this.isMerged(playerId);
        
        return hasBuyItems && hasSellItems && isNotMerged;
    },
    
    /**
     * Check if baskets are currently merged
     * @param {string} playerId - Player ID
     * @returns {boolean} Whether baskets are merged
     */
    isMerged(playerId) {
        return state.ShopSystem.basketMergeState?.[playerId]?.merged || false;
    },
    
    /**
     * Merge buy and sell baskets
     * @param {string} playerId - Player ID
     */
    mergeBaskets(playerId) {
        if (!this.canMergeBaskets(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.NEED_BOTH_BASKETS || "‚ùå Need items in both buy and sell baskets to merge.", playerId);
            return;
        }
        
        if (this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.ALREADY_MERGED || "‚ùå Baskets are already merged.", playerId);
            return;
        }
        
        // Set merge state
        if (!state.ShopSystem.basketMergeState) {
            state.ShopSystem.basketMergeState = {};
        }
        
        state.ShopSystem.basketMergeState[playerId] = {
            merged: true,
            timestamp: Date.now()
        };
        
        this.sendMessage('‚úÖ Baskets merged! You can now checkout both together or haggle for the combined transaction.', playerId);
        this.viewMergedBaskets(playerId);
    },
    
    /**
     * Unmerge baskets
     * @param {string} playerId - Player ID
     */
    unmergeBaskets(playerId) {
        if (!this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.NOT_MERGED || "‚ùå Baskets are not merged.", playerId);
            return;
        }
        
        delete state.ShopSystem.basketMergeState[playerId];
        
        this.sendMessage('‚úÖ Baskets unmerged! You can now modify them separately.', playerId);
    },
    
    /**
     * View merged baskets
     * @param {string} playerId - Player ID
     */
    viewMergedBaskets(playerId) {
        if (!this.isMerged(playerId)) {
            this.sendMessage(this.config?.BASKET_STATE?.ERROR_MESSAGES?.NOT_MERGED || "‚ùå Baskets are not merged.", playerId);
            return;
        }
        
        const buyBasket = state.ShopSystem.playerBaskets[playerId] || [];
        const sellBasket = state.ShopSystem.sellBaskets[playerId] || [];
        
        const buyTotal = this.calculateBasketTotal(buyBasket);
        const sellTotal = this.calculateBasketTotal(sellBasket);
        
        const buyTotalCopper = ShopSystemModules.currency.toCopper(buyTotal);
        const sellTotalCopper = ShopSystemModules.currency.toCopper(sellTotal);
        const netCopper = sellTotalCopper - buyTotalCopper;
        
        const netAmount = ShopSystemModules.currency.fromCopper(Math.abs(netCopper));
        const transactionType = netCopper >= 0 ? "You receive" : "You pay";
        
        const sections = {
            "Buying": this.formatBasketItems(buyBasket),
            "Buy Total": `üí∞${ShopSystemModules.currency.formatCurrency(buyTotal)}`,
            "Selling": this.formatBasketItems(sellBasket),
            "Sell Total": `üí∞${ShopSystemModules.currency.formatCurrency(sellTotal)}`,
            "Net Transaction": `${transactionType}: üí∞${ShopSystemModules.currency.formatCurrency(netAmount)}`,
            "Actions": this.buildMergedBasketActions(playerId)
        };
        
        const menu = ShopSystemModules.menu.createMenu("üîÑ Merged Transaction", sections);
        this.sendMessage(menu, playerId);
    },
    
    // ===================================================================
    // UTILITY METHODS
    // ===================================================================
    
    /**
     * Calculate total price of basket items
     * @param {Array} basket - Basket items
     * @returns {Object} Total price object
     */
    calculateBasketTotal(basket) {
        let totalCopper = 0;
        
        basket.forEach(item => {
            const itemPrice = ShopSystemModules.currency.toCopper(item.price);
            totalCopper += itemPrice * item.quantity;
        });
        
        return ShopSystemModules.currency.fromCopper(totalCopper);
    },
    
    /**
     * Format basket items for display
     * @param {Array} basket - Basket items
     * @returns {string} Formatted item list
     */
    formatBasketItems(basket) {
        if (!basket || basket.length === 0) {
            return "No items";
        }
        
        return basket.map(item => {
            const qtyStr = item.quantity > 1 ? ` (x${item.quantity})` : '';
            return `‚Ä¢ ${item.name}${qtyStr} - ${ShopSystemModules.currency.formatCurrency(item.price)} each`;
        }).join('\n');
    },
    
    /**
     * Build action buttons for buy basket
     * @param {string} playerId - Player ID
     * @param {boolean} canMerge - Whether merging is possible
     * @returns {string} Action buttons
     */
    buildBuyBasketActions(playerId, canMerge) {
        const actions = [
            "[üí∞ Checkout](!shop basket checkout)",
            "[üóëÔ∏è Clear Basket](!shop basket clear)",
            "[üîä Haggle](!shop basket haggle_buy)"
        ];
        
        if (canMerge) {
            actions.push("[üîÑ Merge with Sell Basket](!shop basket merge)");
        }
        
        actions.push("[üè™ Back to Shop](!shop)");
        
        return actions.join(" ");
    },
    
    /**
     * Build action buttons for sell basket
     * @param {string} playerId - Player ID
     * @param {boolean} canMerge - Whether merging is possible
     * @returns {string} Action buttons
     */
    buildSellBasketActions(playerId, canMerge) {
        const actions = [
            "[üí∞ Complete Sale](!shop sell checkout)",
            "[üóëÔ∏è Clear Basket](!shop sell clear)",
            "[üîä Haggle](!shop basket haggle_sell)"
        ];
        
        if (canMerge) {
            actions.push("[üîÑ Merge with Buy Basket](!shop basket merge)");
        }
        
        actions.push("[üè™ Back to Shop](!shop)");
        
        return actions.join(" ");
    },
    
    /**
     * Build action buttons for merged baskets
     * @param {string} playerId - Player ID
     * @returns {string} Action buttons
     */
    buildMergedBasketActions(playerId) {
        return [
            "[üí∞ Complete Transaction](!shop basket complete)",
            "[üîä Haggle Combined](!shop basket haggle_combined)",
            "[üîÑ Unmerge Baskets](!shop basket unmerge)",
            "[üè™ Back to Shop](!shop)"
        ].join(" ");
    },
    
    /**
     * Clear haggle results for player
     * @param {string} playerId - Player ID
     */
    clearHaggleResults(playerId) {
        if (state.ShopSystem.haggleResults?.[playerId]) {
            delete state.ShopSystem.haggleResults[playerId];
            this.log(`Cleared haggle results for player ${playerId}`, 'debug');
        }
    },
    
    /**
     * Save basket state
     */
    saveBasketState() {
        // This would integrate with the existing state saving mechanism
        // For now, state is automatically persisted by Roll20
    },
    
    /**
     * Unlock baskets (remove merge state)
     * @param {string} playerId - Player ID
     */
    unlockBaskets(playerId) {
        if (state.ShopSystem.basketMergeState?.[playerId]) {
            delete state.ShopSystem.basketMergeState[playerId];
        }
    },
    
    /**
     * Get basket summary for receipts/confirmations
     * @param {string} playerId - Player ID
     * @returns {Object} Basket summary
     */
    getBasketSummary(playerId) {
        const buyBasket = state.ShopSystem.playerBaskets[playerId] || [];
        const sellBasket = state.ShopSystem.sellBaskets[playerId] || [];
        
        return {
            buyBasket,
            sellBasket,
            buyTotal: this.calculateBasketTotal(buyBasket),
            sellTotal: this.calculateBasketTotal(sellBasket),
            isMerged: this.isMerged(playerId),
            characterId: state.ShopSystem.sellBasketCharacter?.[playerId]
        };
    },
    
    // Helper methods
    sendMessage(message, playerId) {
        if (playerId) {
            ShopSystem.utils.chat(message, playerId);
        } else {
            ShopSystem.utils.chat(message);
        }
    },
    
    log(message, type = 'info') {
        const prefix = this.config?.LOGGING?.PREFIX?.[type] || 'üìú';
        log(`${prefix} BasketManager: ${message}`);
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.BasketManager = BasketManager;
}

// END MODULE: BasketManager.js


// ===================================================================
// MODULE 5/8: ReceiptGenerator.js
// ===================================================================

/**
 * ReceiptGenerator.js
 * 
 * Receipt generation and transaction recording module for the Shop System
 * Consolidates all receipt creation and transaction history functionality
 * 
 * Replaces:
 * - Combined receipt generation (Lines 7500-8000)
 * - Simple transaction receipts
 * - Receipt formatting and journaling
 * - Transaction history tracking
 * 
 * Estimated savings: 150-200 lines
 */

const ReceiptGenerator = {
    // Reference to ShopConfig for configuration
    config: null,
    
    // Initialize with config reference
    init(shopConfig) {
        this.config = shopConfig;
        return this;
    },
    
    /**
     * Generate a combined receipt for buy/sell transactions
     * @param {string} playerId - Player ID
     * @param {string} characterId - Character ID
     * @param {Array} buyItems - Items purchased
     * @param {Array} sellItems - Items sold
     * @param {number} finalBuyCopper - Final buy cost in copper
     * @param {number} finalSellCopper - Final sell value in copper
     * @param {number} buyAdjustmentCopper - Buy price adjustment from haggling
     * @param {number} sellAdjustmentCopper - Sell price adjustment from haggling
     * @param {number} originalBuyCopper - Original buy cost before haggling
     * @param {number} originalSellCopper - Original sell value before haggling
     * @param {Object} oldCurrency - Player's currency before transaction
     * @param {Object} newCurrency - Player's currency after transaction
     */
    generateCombinedReceipt(playerId, characterId, buyItems, sellItems, finalBuyCopper, finalSellCopper, 
                           buyAdjustmentCopper, sellAdjustmentCopper, originalBuyCopper, originalSellCopper,
                           oldCurrency, newCurrency) {
        
        const character = getObj('character', characterId);
        if (!character) {
            this.log('Failed to generate receipt: Character not found', 'error');
            return;
        }
        
        const player = getObj('player', playerId);
        const playerName = player ? player.get('_displayname') : 'Unknown Player';
        const characterName = character.get('name');
        const shop = ShopSystem.state.activeShop;
        const timestamp = new Date().toLocaleString();
        
        // Calculate net transaction
        const netTransactionCopper = finalSellCopper - finalBuyCopper;
        const transactionType = netTransactionCopper >= 0 ? "received" : "paid";
        const netAmount = ShopSystemModules.currency.fromCopper(Math.abs(netTransactionCopper));
        
        // Build receipt content
        let receiptContent = this.buildReceiptHeader(shop, characterName, playerName, timestamp);
        
        // Add buy section if applicable
        if (buyItems && buyItems.length > 0) {
            receiptContent += this.buildBuySection(buyItems, originalBuyCopper, finalBuyCopper, buyAdjustmentCopper);
        }
        
        // Add sell section if applicable
        if (sellItems && sellItems.length > 0) {
            receiptContent += this.buildSellSection(sellItems, originalSellCopper, finalSellCopper, sellAdjustmentCopper);
        }
        
        // Add transaction summary
        receiptContent += this.buildTransactionSummary(netTransactionCopper, transactionType, netAmount, oldCurrency, newCurrency);
        
        // Add receipt footer
        receiptContent += this.buildReceiptFooter();
        
        // Create handout for receipt
        this.createReceiptHandout(playerId, characterName, receiptContent, timestamp);
        
        this.log(`Generated combined receipt for ${characterName} (${playerName})`, 'info');
    },
    
    /**
     * Generate a simple receipt for single-type transactions
     * @param {string} playerId - Player ID
     * @param {string} characterId - Character ID
     * @param {Array} items - Transaction items
     * @param {string} transactionType - 'buy' or 'sell'
     * @param {Object} totalAmount - Total transaction amount
     * @param {Object} oldCurrency - Currency before transaction
     * @param {Object} newCurrency - Currency after transaction
     */
    generateSimpleReceipt(playerId, characterId, items, transactionType, totalAmount, oldCurrency, newCurrency) {
        const character = getObj('character', characterId);
        if (!character) {
            this.log('Failed to generate receipt: Character not found', 'error');
            return;
        }
        
        const player = getObj('player', playerId);
        const playerName = player ? player.get('_displayname') : 'Unknown Player';
        const characterName = character.get('name');
        const shop = ShopSystem.state.activeShop;
        const timestamp = new Date().toLocaleString();
        
        // Build receipt content
        let receiptContent = this.buildReceiptHeader(shop, characterName, playerName, timestamp);
        
        if (transactionType === 'buy') {
            const totalCopper = ShopSystemModules.currency.toCopper(totalAmount);
            receiptContent += this.buildBuySection(items, totalCopper, totalCopper, 0);
        } else if (transactionType === 'sell') {
            const totalCopper = ShopSystemModules.currency.toCopper(totalAmount);
            receiptContent += this.buildSellSection(items, totalCopper, totalCopper, 0);
        }
        
        // Add transaction summary
        const netCopper = transactionType === 'buy' ? 
            -ShopSystemModules.currency.toCopper(totalAmount) : 
            ShopSystemModules.currency.toCopper(totalAmount);
        const transactionLabel = transactionType === 'buy' ? "paid" : "received";
        
        receiptContent += this.buildTransactionSummary(netCopper, transactionLabel, totalAmount, oldCurrency, newCurrency);
        receiptContent += this.buildReceiptFooter();
        
        // Create handout for receipt
        this.createReceiptHandout(playerId, characterName, receiptContent, timestamp);
        
        this.log(`Generated ${transactionType} receipt for ${characterName} (${playerName})`, 'info');
    },
    
    /**
     * Build receipt header section
     * @param {Object} shop - Shop object
     * @param {string} characterName - Character name
     * @param {string} playerName - Player name
     * @param {string} timestamp - Transaction timestamp
     * @returns {string} Header HTML
     */
    buildReceiptHeader(shop, characterName, playerName, timestamp) {
        const shopName = shop ? shop.name : 'Unknown Shop';
        const merchantName = shop ? (shop.merchant_name || 'Unknown Merchant') : 'Unknown Merchant';
        const location = shop ? (shop.location || 'Unknown Location') : 'Unknown Location';
        
        return `
<div style="font-family: Georgia, serif; max-width: 400px; margin: 0 auto; padding: 20px; border: 2px solid #8B4513; background: #FFF8DC;">
    <div style="text-align: center; border-bottom: 2px solid #8B4513; padding-bottom: 10px; margin-bottom: 15px;">
        <h2 style="margin: 0; color: #8B4513;">${this.escapeHtml(shopName)}</h2>
        <p style="margin: 5px 0; font-style: italic;">${this.escapeHtml(merchantName)}</p>
        <p style="margin: 5px 0; font-size: 0.9em;">${this.escapeHtml(location)}</p>
    </div>
    
    <div style="margin-bottom: 15px;">
        <p><strong>Customer:</strong> ${this.escapeHtml(characterName)} (${this.escapeHtml(playerName)})</p>
        <p><strong>Date:</strong> ${this.escapeHtml(timestamp)}</p>
    </div>
`;
    },
    
    /**
     * Build buy section of receipt
     * @param {Array} buyItems - Items purchased
     * @param {number} originalCopper - Original cost in copper
     * @param {number} finalCopper - Final cost in copper
     * @param {number} adjustmentCopper - Price adjustment from haggling
     * @returns {string} Buy section HTML
     */
    buildBuySection(buyItems, originalCopper, finalCopper, adjustmentCopper) {
        let section = `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; color: #8B4513; border-bottom: 1px solid #8B4513;">Items Purchased</h3>
        <table style="width: 100%; border-collapse: collapse;">
`;
        
        buyItems.forEach(item => {
            const itemTotal = ShopSystemModules.currency.toCopper(item.price) * item.quantity;
            const formattedTotal = ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(itemTotal));
            
            section += `
            <tr>
                <td style="padding: 3px 0;">${this.escapeHtml(item.name)}</td>
                <td style="text-align: center; padding: 3px 5px;">x${item.quantity}</td>
                <td style="text-align: right; padding: 3px 0;">${formattedTotal}</td>
            </tr>
`;
        });
        
        section += `
            <tr style="border-top: 1px solid #8B4513;">
                <td colspan="2" style="padding: 5px 0; font-weight: bold;">Subtotal:</td>
                <td style="text-align: right; padding: 5px 0; font-weight: bold;">${ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(originalCopper))}</td>
            </tr>
`;
        
        // Add haggle adjustment if applicable
        if (adjustmentCopper !== 0) {
            const adjustmentType = adjustmentCopper < 0 ? "Discount" : "Markup";
            const adjustmentAmount = ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(Math.abs(adjustmentCopper)));
            const adjustmentPercent = originalCopper > 0 ? Math.round(Math.abs(adjustmentCopper / originalCopper) * 100) : 0;
            
            section += `
            <tr>
                <td colspan="2" style="padding: 3px 0; color: ${adjustmentCopper < 0 ? '#228B22' : '#DC143C'};">${adjustmentType} (${adjustmentPercent}%):</td>
                <td style="text-align: right; padding: 3px 0; color: ${adjustmentCopper < 0 ? '#228B22' : '#DC143C'};">${adjustmentCopper < 0 ? '-' : '+'}${adjustmentAmount}</td>
            </tr>
`;
        }
        
        section += `
            <tr style="border-top: 2px solid #8B4513;">
                <td colspan="2" style="padding: 5px 0; font-weight: bold;">Total Paid:</td>
                <td style="text-align: right; padding: 5px 0; font-weight: bold;">${ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(finalCopper))}</td>
            </tr>
        </table>
    </div>
`;
        
        return section;
    },
    
    /**
     * Build sell section of receipt
     * @param {Array} sellItems - Items sold
     * @param {number} originalCopper - Original value in copper
     * @param {number} finalCopper - Final value in copper
     * @param {number} adjustmentCopper - Price adjustment from haggling
     * @returns {string} Sell section HTML
     */
    buildSellSection(sellItems, originalCopper, finalCopper, adjustmentCopper) {
        let section = `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; color: #8B4513; border-bottom: 1px solid #8B4513;">Items Sold</h3>
        <table style="width: 100%; border-collapse: collapse;">
`;
        
        sellItems.forEach(item => {
            const itemTotal = ShopSystemModules.currency.toCopper(item.price) * item.quantity;
            const formattedTotal = ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(itemTotal));
            
            section += `
            <tr>
                <td style="padding: 3px 0;">${this.escapeHtml(item.name)}</td>
                <td style="text-align: center; padding: 3px 5px;">x${item.quantity}</td>
                <td style="text-align: right; padding: 3px 0;">${formattedTotal}</td>
            </tr>
`;
        });
        
        section += `
            <tr style="border-top: 1px solid #8B4513;">
                <td colspan="2" style="padding: 5px 0; font-weight: bold;">Subtotal:</td>
                <td style="text-align: right; padding: 5px 0; font-weight: bold;">${ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(originalCopper))}</td>
            </tr>
`;
        
        // Add haggle adjustment if applicable
        if (adjustmentCopper !== 0) {
            const adjustmentType = adjustmentCopper > 0 ? "Bonus" : "Penalty";
            const adjustmentAmount = ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(Math.abs(adjustmentCopper)));
            const adjustmentPercent = originalCopper > 0 ? Math.round(Math.abs(adjustmentCopper / originalCopper) * 100) : 0;
            
            section += `
            <tr>
                <td colspan="2" style="padding: 3px 0; color: ${adjustmentCopper > 0 ? '#228B22' : '#DC143C'};">${adjustmentType} (${adjustmentPercent}%):</td>
                <td style="text-align: right; padding: 3px 0; color: ${adjustmentCopper > 0 ? '#228B22' : '#DC143C'};">${adjustmentCopper > 0 ? '+' : ''}${adjustmentAmount}</td>
            </tr>
`;
        }
        
        section += `
            <tr style="border-top: 2px solid #8B4513;">
                <td colspan="2" style="padding: 5px 0; font-weight: bold;">Total Received:</td>
                <td style="text-align: right; padding: 5px 0; font-weight: bold;">${ShopSystemModules.currency.formatCurrency(ShopSystemModules.currency.fromCopper(finalCopper))}</td>
            </tr>
        </table>
    </div>
`;
        
        return section;
    },
    
    /**
     * Build transaction summary section
     * @param {number} netTransactionCopper - Net transaction amount in copper
     * @param {string} transactionType - Type of transaction
     * @param {Object} netAmount - Net amount object
     * @param {Object} oldCurrency - Currency before transaction
     * @param {Object} newCurrency - Currency after transaction
     * @returns {string} Summary section HTML
     */
    buildTransactionSummary(netTransactionCopper, transactionType, netAmount, oldCurrency, newCurrency) {
        const netAmountFormatted = ShopSystemModules.currency.formatCurrency(netAmount);
        const oldCurrencyFormatted = ShopSystemModules.currency.formatCurrency(oldCurrency);
        const newCurrencyFormatted = ShopSystemModules.currency.formatCurrency(newCurrency);
        
        return `
    <div style="margin-bottom: 15px; padding: 10px; background: #F5F5DC; border: 1px solid #8B4513;">
        <h3 style="margin: 0 0 10px 0; color: #8B4513;">Transaction Summary</h3>
        <p><strong>Net Amount ${transactionType.charAt(0).toUpperCase() + transactionType.slice(1)}:</strong> ${netAmountFormatted}</p>
        <p><strong>Currency Before:</strong> ${oldCurrencyFormatted}</p>
        <p><strong>Currency After:</strong> ${newCurrencyFormatted}</p>
    </div>
`;
    },
    
    /**
     * Build receipt footer
     * @returns {string} Footer HTML
     */
    buildReceiptFooter() {
        return `
    <div style="text-align: center; margin-top: 20px; padding-top: 10px; border-top: 2px solid #8B4513; font-size: 0.9em; color: #8B4513;">
        <p><em>Thank you for your business!</em></p>
        <p style="font-size: 0.8em;">Receipt generated by ShopSystem v${this.config?.VERSION || '1.0'}</p>
    </div>
</div>
`;
    },
    
    /**
     * Create a handout for the receipt
     * @param {string} playerId - Player ID
     * @param {string} characterName - Character name
     * @param {string} receiptContent - Receipt HTML content
     * @param {string} timestamp - Transaction timestamp
     */
    createReceiptHandout(playerId, characterName, receiptContent, timestamp) {
        try {
            const shop = ShopSystem.state.activeShop;
            const shopName = shop ? shop.name : 'Unknown Shop';
            const handoutName = `Receipt: ${characterName} - ${shopName} - ${new Date().toLocaleDateString()}`;
            
            // Check if similar recent receipt exists
            const existingReceipts = findObjs({
                _type: 'handout',
                name: handoutName
            });
            
            let finalHandoutName = handoutName;
            if (existingReceipts.length > 0) {
                finalHandoutName = `${handoutName} (${existingReceipts.length + 1})`;
            }
            
            const receiptHandout = createObj('handout', {
                name: finalHandoutName,
                inplayerjournals: playerId,
                archived: false
            });
            
            receiptHandout.set('notes', receiptContent);
            
            this.log(`Created receipt handout: ${finalHandoutName}`, 'debug');
            
        } catch (error) {
            this.log(`Error creating receipt handout: ${error.message}`, 'error');
        }
    },
    
    /**
     * Generate a haggle result receipt addition
     * @param {Object} haggleResult - Haggle result details
     * @returns {string} Haggle section HTML
     */
    buildHaggleSection(haggleResult) {
        if (!haggleResult || !haggleResult.applied) {
            return '';
        }
        
        const { skillType, rollValue, dc, success, adjustmentPercent } = haggleResult;
        const resultText = success ? 'Success' : 'Failed';
        const resultColor = success ? '#228B22' : '#DC143C';
        
        return `
    <div style="margin-bottom: 15px; padding: 8px; background: #FFF8DC; border: 1px solid #DDD;">
        <h4 style="margin: 0 0 8px 0; color: #8B4513;">Haggle Attempt</h4>
        <p><strong>Skill Used:</strong> ${this.escapeHtml(skillType)}</p>
        <p><strong>Roll:</strong> ${rollValue} vs DC ${dc}</p>
        <p style="color: ${resultColor};"><strong>Result:</strong> ${resultText}</p>
        ${adjustmentPercent !== 0 ? `<p><strong>Price Adjustment:</strong> ${adjustmentPercent > 0 ? '+' : ''}${Math.round(adjustmentPercent * 100)}%</p>` : ''}
    </div>
`;
    },
    
    /**
     * Create a transaction log entry
     * @param {Object} transactionData - Transaction details
     */
    logTransaction(transactionData) {
        try {
            // Find or create transaction log handout
            let logHandout = findObjs({
                _type: 'handout',
                name: 'ShopSystem Transaction Log'
            })[0];
            
            if (!logHandout) {
                logHandout = createObj('handout', {
                    name: 'ShopSystem Transaction Log',
                    inplayerjournals: '',
                    archived: false
                });
                
                const logHeader = `
<h2>ShopSystem Transaction Log</h2>
<p><em>Automatic transaction logging for audit purposes</em></p>
<hr>
`;
                logHandout.set('notes', logHeader);
            }
            
            // Build log entry
            const timestamp = new Date().toLocaleString();
            const logEntry = `
<div style="border-bottom: 1px solid #ccc; margin-bottom: 10px; padding-bottom: 10px;">
    <h4>${timestamp}</h4>
    <p><strong>Player:</strong> ${this.escapeHtml(transactionData.playerName)}</p>
    <p><strong>Character:</strong> ${this.escapeHtml(transactionData.characterName)}</p>
    <p><strong>Shop:</strong> ${this.escapeHtml(transactionData.shopName)}</p>
    <p><strong>Type:</strong> ${this.escapeHtml(transactionData.type)}</p>
    <p><strong>Amount:</strong> ${this.escapeHtml(transactionData.amount)}</p>
    ${transactionData.items ? `<p><strong>Items:</strong> ${transactionData.items}</p>` : ''}
</div>
`;
            
            // Append to existing log
            logHandout.get('notes', function(currentNotes) {
                const updatedNotes = (currentNotes || '') + logEntry;
                logHandout.set('notes', updatedNotes);
            });
            
            this.log('Transaction logged successfully', 'debug');
            
        } catch (error) {
            this.log(`Error logging transaction: ${error.message}`, 'error');
        }
    },
    
    /**
     * Escape HTML characters for safe display
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    escapeHtml(text) {
        if (!text) return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    },
    
    /**
     * Generate receipt for failed transaction
     * @param {string} playerId - Player ID
     * @param {string} reason - Failure reason
     * @param {Object} attemptedTransaction - Transaction that failed
     */
    generateFailureReceipt(playerId, reason, attemptedTransaction) {
        const player = getObj('player', playerId);
        const playerName = player ? player.get('_displayname') : 'Unknown Player';
        const timestamp = new Date().toLocaleString();
        
        const failureContent = `
<div style="font-family: Georgia, serif; max-width: 400px; margin: 0 auto; padding: 20px; border: 2px solid #DC143C; background: #FFF0F0;">
    <div style="text-align: center; border-bottom: 2px solid #DC143C; padding-bottom: 10px; margin-bottom: 15px;">
        <h2 style="margin: 0; color: #DC143C;">Transaction Failed</h2>
    </div>
    
    <div style="margin-bottom: 15px;">
        <p><strong>Player:</strong> ${this.escapeHtml(playerName)}</p>
        <p><strong>Date:</strong> ${this.escapeHtml(timestamp)}</p>
        <p><strong>Reason:</strong> ${this.escapeHtml(reason)}</p>
    </div>
    
    <div style="text-align: center; margin-top: 20px; padding-top: 10px; border-top: 2px solid #DC143C; font-size: 0.9em; color: #DC143C;">
        <p><em>Please try again or contact the GM for assistance.</em></p>
    </div>
</div>
`;
        
        this.createReceiptHandout(playerId, 'Failed Transaction', failureContent, timestamp);
        this.log(`Generated failure receipt for ${playerName}: ${reason}`, 'info');
    },
    
    // Helper methods
    log(message, type = 'info') {
        const prefix = this.config?.LOGGING?.PREFIX?.[type] || 'üìú';
        log(`${prefix} ReceiptGenerator: ${message}`);
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.ReceiptGenerator = ReceiptGenerator;
}

// END MODULE: ReceiptGenerator.js


// ===================================================================
// MODULE 6/8: StockManager.js
// ===================================================================

/**
 * StockManager.js
 * 
 * Stock and inventory management module for the Shop System
 * Consolidates all stock operations, inventory management, and stock generation
 * 
 * Replaces:
 * - Stock management functions (Lines 4000-5000)
 * - Random stock generation
 * - Inventory display and formatting
 * - Stock manipulation operations
 * - Restock functionality
 * 
 * Estimated savings: 200-300 lines
 */

const StockManager = {
    // Reference to ShopConfig for configuration
    config: null,
    
    // Initialize with config reference
    init(shopConfig) {
        this.config = shopConfig;
        return this;
    },
    
    /**
     * Add item to shop stock
     * @param {string} itemId - Item ID to add
     * @param {number} quantity - Quantity to add
     * @param {Object} customPrice - Custom price override
     * @returns {Promise} Promise resolving to operation result
     */
    async addItemToStock(itemId, quantity = 1, customPrice = null) {
        if (!ShopSystem.state.activeShop) {
            return { success: false, error: "No active shop selected" };
        }
        
        try {
            const shop = ShopSystem.state.activeShop;
            
            if (!shop || !shop.id) {
                throw new Error("Active shop is not properly set");
            }
            
            // Get item from database
            const items = await ShopSystem.database.listItems('all', 'all');
            const item = items.find(i => i.id === itemId);
            
            if (!item) {
                throw new Error(`Item ${itemId} not found in database`);
            }
            
            // Ensure shop inventory structure
            if (!shop.inventory) shop.inventory = {};
            if (!shop.inventory[item.category]) {
                shop.inventory[item.category] = [];
            }
            
            // Check if item already exists in shop
            const existingItemIndex = shop.inventory[item.category].findIndex(i => i.id === itemId);
            
            if (existingItemIndex !== -1) {
                // Update existing item
                const existingItem = shop.inventory[item.category][existingItemIndex];
                if (customPrice) {
                    existingItem.price = customPrice;
                    this.log(`Updated price of ${item.name} to ${ShopSystemModules.currency.formatCurrency(customPrice)}`, "info");
                }
                existingItem.quantity += quantity;
                existingItem.maxStock = (existingItem.maxStock || 0) + quantity;
                this.log(`Updated quantity of ${item.name} to ${existingItem.quantity}`, "info");
            } else {
                // Add new item to inventory
                shop.inventory[item.category].push({
                    id: item.id,
                    name: item.name,
                    quantity: quantity,
                    maxStock: quantity,
                    price: customPrice || item.price,
                    category: item.category,
                    rarity: item.rarity || 'common',
                    description: item.description || ""
                });
                
                const logPrice = customPrice ? ShopSystemModules.currency.formatCurrency(customPrice) : 'default';
                this.log(`Added ${quantity} ${item.name} (Price: ${logPrice}, MaxStock: ${quantity}) to shop inventory`, "info");
            }
            
            // Track last modified item
            this.trackLastModifiedItem(shop.id, itemId);
            
            // Save shop data
            const shopHandout = getObj("handout", shop.id);
            if (shopHandout) {
                shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
                return { success: true, item: item, quantity: quantity, priceUsed: customPrice || item.price };
            } else {
                throw new Error("Could not save shop data");
            }
            
        } catch (error) {
            this.log(`Error adding item to stock: ${error.message}`, 'error');
            return { success: false, error: error.message };
        }
    },
    
    /**
     * Remove item from shop stock
     * @param {string} itemId - Item ID to remove
     * @param {number} quantity - Quantity to remove (0 = remove all)
     * @returns {boolean} Success status
     */
    removeItemFromStock(itemId, quantity = 0) {
        if (!ShopSystem.state.activeShop) {
            this.log("No active shop selected", "error");
            return false;
        }
        
        const shop = ShopSystem.state.activeShop;
        let item = null;
        let itemCategory = '';
        let itemIndex = -1;
        
        // Find the item
        for (const category in shop.inventory) {
            if (Array.isArray(shop.inventory[category])) {
                const index = shop.inventory[category].findIndex(i => i.id === itemId);
                if (index !== -1) {
                    item = shop.inventory[category][index];
                    itemCategory = category;
                    itemIndex = index;
                    break;
                }
            }
        }
        
        if (!item) {
            this.log(`Item ${itemId} not found in shop inventory`, "error");
            return false;
        }
        
        if (quantity === 0 || quantity >= item.quantity) {
            // Remove item entirely
            shop.inventory[itemCategory].splice(itemIndex, 1);
            this.log(`Removed ${item.name} completely from shop inventory`, "info");
        } else {
            // Reduce quantity
            item.quantity -= quantity;
            this.log(`Reduced ${item.name} quantity by ${quantity} (now ${item.quantity})`, "info");
        }
        
        // Save shop data
        const shopHandout = getObj("handout", shop.id);
        if (shopHandout) {
            shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
            return true;
        }
        
        return false;
    },
    
    /**
     * Set item maximum stock
     * @param {string} itemId - Item ID
     * @param {number} newMaxStock - New maximum stock value
     * @returns {boolean} Success status
     */
    setItemMaxStock(itemId, newMaxStock) {
        if (!ShopSystem.state.activeShop) {
            this.log("No active shop selected", "error");
            return false;
        }
        
        const shop = ShopSystem.state.activeShop;
        let item = null;
        let itemCategory = '';
        let itemIndex = -1;
        
        // Find the item
        for (const category in shop.inventory) {
            if (Array.isArray(shop.inventory[category])) {
                const index = shop.inventory[category].findIndex(i => i.id === itemId);
                if (index !== -1) {
                    item = shop.inventory[category][index];
                    itemCategory = category;
                    itemIndex = index;
                    break;
                }
            }
        }
        
        if (!item) {
            this.log(`Item ${itemId} not found in shop inventory`, "error");
            return false;
        }
        
        if (newMaxStock === 0) {
            // Remove item entirely
            shop.inventory[itemCategory].splice(itemIndex, 1);
            this.log(`Removed ${item.name} from stock (max stock set to 0)`, "info");
        } else {
            item.maxStock = newMaxStock;
            // Ensure current quantity doesn't exceed new max
            if (item.quantity > newMaxStock) {
                item.quantity = newMaxStock;
            }
            this.log(`Updated max stock of ${item.name} to ${newMaxStock}`, "info");
        }
        
        // Save shop data
        const shopHandout = getObj("handout", shop.id);
        if (shopHandout) {
            shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
            return true;
        }
        
        return false;
    },
    
    /**
     * Set item current quantity
     * @param {string} itemId - Item ID
     * @param {number} newQuantity - New quantity
     * @returns {boolean} Success status
     */
    setItemQuantity(itemId, newQuantity) {
        if (!ShopSystem.state.activeShop) {
            this.log("No active shop selected", "error");
            return false;
        }
        
        const shop = ShopSystem.state.activeShop;
        let item = null;
        
        // Find the item
        for (const category in shop.inventory) {
            if (Array.isArray(shop.inventory[category])) {
                const foundItem = shop.inventory[category].find(i => i.id === itemId);
                if (foundItem) {
                    item = foundItem;
                    break;
                }
            }
        }
        
        if (!item) {
            this.log(`Item ${itemId} not found in shop inventory`, "error");
            return false;
        }
        
        const maxStock = item.maxStock || newQuantity;
        const cappedQuantity = Math.min(newQuantity, maxStock);
        
        item.quantity = cappedQuantity;
        this.log(`Updated quantity of ${item.name} to ${cappedQuantity}`, "info");
        
        // Save shop data
        const shopHandout = getObj("handout", shop.id);
        if (shopHandout) {
            shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
            return true;
        }
        
        return false;
    },
    
    /**
     * Set item price
     * @param {string} itemId - Item ID
     * @param {Object} newPrice - New price object
     * @returns {boolean} Success status
     */
    setItemPrice(itemId, newPrice) {
        if (!ShopSystem.state.activeShop) {
            this.log("No active shop selected", "error");
            return false;
        }
        
        const shop = ShopSystem.state.activeShop;
        let item = null;
        
        // Find the item
        for (const category in shop.inventory) {
            if (Array.isArray(shop.inventory[category])) {
                const foundItem = shop.inventory[category].find(i => i.id === itemId);
                if (foundItem) {
                    item = foundItem;
                    break;
                }
            }
        }
        
        if (!item) {
            this.log(`Item ${itemId} not found in shop inventory`, "error");
            return false;
        }
        
        item.price = newPrice;
        this.log(`Updated price of ${item.name} to ${ShopSystemModules.currency.formatCurrency(newPrice)}`, "info");
        
        // Save shop data
        const shopHandout = getObj("handout", shop.id);
        if (shopHandout) {
            shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
            return true;
        }
        
        return false;
    },
    
    /**
     * Generate random stock for shop
     * @param {Object} options - Generation options
     * @returns {Promise} Promise resolving to generated items
     */
    async generateRandomStock(options = {}) {
        const {
            numItems = this.config?.STOCK_GENERATION?.DEFAULT_RANDOM_ITEMS || 10,
            categories = this.config?.ITEM?.CATEGORIES || ['weapons', 'equipment', 'potions'],
            rarities = this.config?.ITEM?.RARITIES || ['common', 'uncommon', 'rare'],
            useWeights = true
        } = options;
        
        try {
            // Get all items from database
            const allItems = await ShopSystem.database.listItems('all', 'all');
            
            if (!allItems || allItems.length === 0) {
                throw new Error("No items found in database");
            }
            
            const generatedItems = [];
            const rarityChances = this.config?.STOCK_GENERATION?.RARITY_CHANCES || {
                common: 70,
                uncommon: 20,
                rare: 8,
                "very rare": 1.5,
                legendary: 0.5
            };
            
            for (let i = 0; i < numItems; i++) {
                // Select rarity based on weights
                const selectedRarity = this.selectWeightedRarity(rarityChances);
                
                // Select category
                const selectedCategory = categories[Math.floor(Math.random() * categories.length)];
                
                // Find items matching criteria
                const availableItems = allItems.filter(item => 
                    item.rarity === selectedRarity && 
                    item.category === selectedCategory
                );
                
                if (availableItems.length > 0) {
                    const selectedItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                    const quantity = this.generateQuantityForRarity(selectedRarity);
                    
                    generatedItems.push({
                        ...selectedItem,
                        quantity: quantity,
                        maxStock: quantity
                    });
                }
            }
            
            // Combine duplicates
            const combinedItems = this.combineDuplicateItems(generatedItems);
            
            this.log(`Generated ${combinedItems.length} unique items for stock`, "info");
            return combinedItems;
            
        } catch (error) {
            this.log(`Error generating random stock: ${error.message}`, 'error');
            return [];
        }
    },
    
    /**
     * Restock shop to maximum levels
     * @param {Object} options - Restock options
     * @returns {number} Number of items restocked
     */
    restockShop(options = {}) {
        if (!ShopSystem.state.activeShop) {
            this.log("No active shop selected", "error");
            return 0;
        }
        
        const shop = ShopSystem.state.activeShop;
        let itemsRestocked = 0;
        
        if (!shop.inventory) {
            this.log("Shop has no inventory to restock", "warn");
            return 0;
        }
        
        // Process each category
        for (const category in shop.inventory) {
            if (Array.isArray(shop.inventory[category])) {
                shop.inventory[category].forEach(item => {
                    if (item.maxStock && item.quantity < item.maxStock) {
                        const oldQuantity = item.quantity;
                        item.quantity = item.maxStock;
                        itemsRestocked++;
                        this.log(`Restocked ${item.name}: ${oldQuantity} ‚Üí ${item.quantity}`, "debug");
                    }
                });
            }
        }
        
        if (itemsRestocked > 0) {
            // Save shop data
            const shopHandout = getObj("handout", shop.id);
            if (shopHandout) {
                shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
            }
            
            this.log(`Restocked ${itemsRestocked} items in ${shop.name}`, "info");
        } else {
            this.log("No items needed restocking", "info");
        }
        
        return itemsRestocked;
    },
    
    /**
     * Clear all stock from shop
     * @returns {number} Number of items cleared
     */
    clearAllStock() {
        if (!ShopSystem.state.activeShop) {
            this.log("No active shop selected", "error");
            return 0;
        }
        
        const shop = ShopSystem.state.activeShop;
        let itemsCleared = 0;
        
        if (shop.inventory) {
            for (const category in shop.inventory) {
                if (Array.isArray(shop.inventory[category])) {
                    itemsCleared += shop.inventory[category].length;
                    shop.inventory[category] = [];
                }
            }
        }
        
        // Save shop data
        const shopHandout = getObj("handout", shop.id);
        if (shopHandout) {
            shopHandout.set("gmnotes", JSON.stringify(shop, null, 2));
        }
        
        this.log(`Cleared ${itemsCleared} items from ${shop.name}`, "info");
        return itemsCleared;
    },
    
    /**
     * Format inventory for display
     * @param {Object} shop - Shop object
     * @returns {string} Formatted inventory display
     */
    formatInventory(shop) {
        if (!shop || !shop.inventory || Object.values(shop.inventory).every(arr => !arr || arr.length === 0)) {
            return "No items in stock.";
        }
        
        const stockLines = [];
        const categoryEmojis = this.config?.EMOJI?.CATEGORY || {};
        const rarityEmojis = this.config?.EMOJI?.RARITY || {};
        const qtyColor = '#FF8C00';
        const newItemColor = '#28a745';
        
        // Get highlighted items
        const lastModifiedId = this.getLastModifiedItem(shop.id);
        const idsToHighlight = this.getHighlightBatch(shop.id) || [];
        
        Object.entries(shop.inventory).forEach(([category, items]) => {
            if (items && items.length > 0) {
                const categoryEmoji = categoryEmojis[category] || "üì¶";
                stockLines.push(`<span style="color:#3399FF;font-weight:bold;">${categoryEmoji} ${category.charAt(0).toUpperCase() + category.slice(1)}:</span>`);
                
                items.forEach(item => {
                    const rarityEmoji = rarityEmojis[item.rarity] || '‚ö™';
                    const isHighlighted = idsToHighlight.includes(item.id) || item.id === lastModifiedId;
                    
                    let nameAndPriceSection;
                    
                    if (item.quantity === 0) {
                        const maxStockDisplay = item.maxStock !== undefined ? item.maxStock : '?';
                        const outOfStockStr = `<span style="color:${qtyColor};font-weight:bold;">(üî¥/${maxStockDisplay}) Out of Stock</span>`;
                        nameAndPriceSection = `${rarityEmoji} ${outOfStockStr} - ${item.name} - <span style="color:inherit;">üí∞${ShopSystemModules.currency.formatCurrency(item.price)}</span>`;
                    } else {
                        const qtyDisplay = `<span style="color:${qtyColor};font-weight:bold;">(${item.quantity}/${item.maxStock ?? item.quantity})</span>`;
                        nameAndPriceSection = `${rarityEmoji} ${qtyDisplay} ${item.name} - <span style="color:inherit;">üí∞${ShopSystemModules.currency.formatCurrency(item.price)}</span>`;
                    }
                    
                    if (isHighlighted) {
                        nameAndPriceSection = `üîÑ <span style="color:${newItemColor};">${nameAndPriceSection}</span>`;
                    }
                    
                    stockLines.push(`‚Ä¢ ${nameAndPriceSection}`);
                    stockLines.push(`[üìù Edit](!shop stock qty ${item.id}) [‚ùå Remove](!shop stock removeitem ${item.id})`);
                });
            }
        });
        
        // Clear highlight tracking
        this.clearHighlightTracking(shop.id);
        
        return stockLines.length > 0 ? stockLines.join('\n') : 'No items in stock.';
    },
    
    /**
     * Get shop categories with item counts
     * @param {Object} shop - Shop object
     * @returns {Array} Categories with counts
     */
    getShopCategories(shop) {
        if (!shop || !shop.inventory) {
            return [];
        }
        
        const categories = [];
        const categoryEmojis = this.config?.EMOJI?.CATEGORY || {};
        
        for (const [category, items] of Object.entries(shop.inventory)) {
            if (items && items.length > 0) {
                const emoji = categoryEmojis[category] || "üì¶";
                const totalItems = items.reduce((sum, item) => sum + (item.quantity || 0), 0);
                
                categories.push({
                    name: category,
                    emoji: emoji,
                    itemCount: items.length,
                    totalQuantity: totalItems
                });
            }
        }
        
        return categories.sort((a, b) => {
            const orderA = this.config?.ITEM?.CATEGORIES?.indexOf(a.name) ?? 999;
            const orderB = this.config?.ITEM?.CATEGORIES?.indexOf(b.name) ?? 999;
            return orderA - orderB;
        });
    },
    
    // ===================================================================
    // UTILITY METHODS
    // ===================================================================
    
    /**
     * Select rarity based on weighted chances
     * @param {Object} rarityChances - Rarity weights
     * @returns {string} Selected rarity
     */
    selectWeightedRarity(rarityChances) {
        const totalWeight = Object.values(rarityChances).reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * totalWeight;
        
        for (const [rarity, weight] of Object.entries(rarityChances)) {
            random -= weight;
            if (random <= 0) {
                return rarity;
            }
        }
        
        return 'common'; // Fallback
    },
    
    /**
     * Generate quantity for rarity
     * @param {string} rarity - Item rarity
     * @returns {number} Generated quantity
     */
    generateQuantityForRarity(rarity) {
        const quantityConfig = this.config?.STOCK_GENERATION?.DEFAULT_QUANTITY || {
            common: "3d6",
            uncommon: "2d4",
            rare: "1d4",
            "very rare": "1d2",
            legendary: "1d2-1"
        };
        
        const diceNotation = quantityConfig[rarity] || "1d4";
        return this.rollDice(diceNotation);
    },
    
    /**
     * Roll dice notation
     * @param {string} notation - Dice notation (e.g., "3d6", "1d2-1")
     * @returns {number} Roll result
     */
    rollDice(notation) {
        if (!isNaN(notation)) {
            return parseInt(notation);
        }
        
        const match = notation.match(/^(\d+)d(\d+)(?:-(\d+))?$/);
        if (!match) {
            this.log(`Invalid dice notation: ${notation}. Defaulting to 1.`, 'warn');
            return 1;
        }
        
        const [_, numDiceStr, numSidesStr, subtractStr] = match;
        const numDice = parseInt(numDiceStr);
        const numSides = parseInt(numSidesStr);
        const subtractValue = subtractStr ? parseInt(subtractStr) : 0;
        
        if (numDice <= 0 || numSides <= 0) {
            this.log(`Invalid dice parameters in notation: ${notation}. Defaulting to 1.`, 'warn');
            return 1;
        }
        
        let total = 0;
        for (let i = 0; i < numDice; i++) {
            total += Math.floor(Math.random() * numSides) + 1;
        }
        
        return Math.max(0, total - subtractValue);
    },
    
    /**
     * Combine duplicate items in generated stock
     * @param {Array} items - Generated items
     * @returns {Array} Combined items
     */
    combineDuplicateItems(items) {
        const combined = [];
        
        items.forEach(item => {
            const existing = combined.find(i => i.id === item.id);
            if (existing) {
                existing.quantity += item.quantity;
                existing.maxStock = (existing.maxStock || 0) + (item.maxStock || item.quantity);
            } else {
                combined.push({ ...item });
            }
        });
        
        return combined;
    },
    
    /**
     * Track last modified item for highlighting
     * @param {string} shopId - Shop ID
     * @param {string} itemId - Item ID
     */
    trackLastModifiedItem(shopId, itemId) {
        if (!state.ShopSystem.lastModifiedStockItem) {
            state.ShopSystem.lastModifiedStockItem = {};
        }
        state.ShopSystem.lastModifiedStockItem[shopId] = itemId;
        this.log(`Tracked last modified item for shop ${shopId}: ${itemId}`, 'debug');
    },
    
    /**
     * Get last modified item for highlighting
     * @param {string} shopId - Shop ID
     * @returns {string} Item ID
     */
    getLastModifiedItem(shopId) {
        return state.ShopSystem.lastModifiedStockItem?.[shopId] || null;
    },
    
    /**
     * Get batch of items to highlight
     * @param {string} shopId - Shop ID
     * @returns {Array} Array of item IDs
     */
    getHighlightBatch(shopId) {
        return state.ShopSystem.justAddedStockIds?.[shopId] || [];
    },
    
    /**
     * Clear highlight tracking after display
     * @param {string} shopId - Shop ID
     */
    clearHighlightTracking(shopId) {
        if (state.ShopSystem.justAddedStockIds?.[shopId]) {
            delete state.ShopSystem.justAddedStockIds[shopId];
            this.log(`Cleared batch highlight IDs for shop ${shopId}`, 'debug');
        }
        
        if (state.ShopSystem.lastModifiedStockItem?.[shopId]) {
            delete state.ShopSystem.lastModifiedStockItem[shopId];
            this.log(`Cleared single highlight ID for shop ${shopId}`, 'debug');
        }
    },
    
    /**
     * Validate shop inventory structure
     * @param {Object} shop - Shop object
     * @returns {boolean} Whether inventory is valid
     */
    validateInventory(shop) {
        if (!shop || !shop.inventory) {
            return false;
        }
        
        for (const [category, items] of Object.entries(shop.inventory)) {
            if (!Array.isArray(items)) {
                this.log(`Invalid inventory structure: category ${category} is not an array`, 'warn');
                return false;
            }
            
            for (const item of items) {
                if (!item.id || !item.name || !item.price) {
                    this.log(`Invalid item in inventory: missing required fields`, 'warn');
                    return false;
                }
            }
        }
        
        return true;
    },
    
    // Helper methods
    log(message, type = 'info') {
        const prefix = this.config?.LOGGING?.PREFIX?.[type] || 'üìú';
        log(`${prefix} StockManager: ${message}`);
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.StockManager = StockManager;
}

// END MODULE: StockManager.js


// ===================================================================
// MODULE 7/8: DatabaseManager.js
// ===================================================================

/**
 * DatabaseManager.js
 * 
 * Database operations and item management module for the Shop System
 * Consolidates all database functionality, item CRUD operations, and data persistence
 * 
 * Replaces:
 * - Database initialization and management (Lines 1070-1400)
 * - Item CRUD operations (Lines 1900-2500)
 * - Character currency operations (Lines 2100-2250)
 * - Database command handling (Lines 1400-1900)
 * - Roll20 object interactions (findObjs, createObj, getObj calls)
 * 
 * Estimated savings: 400-500 lines
 */

const DatabaseManager = {
    // Reference to ShopConfig for configuration
    config: null,
    
    // Initialize with config reference
    init(shopConfig) {
        this.config = shopConfig;
        return this;
    },
    
    // ===================================================================
    // DATABASE INITIALIZATION AND CORE OPERATIONS
    // ===================================================================
    
    /**
     * Initialize the item database
     * @returns {Object} Database handout object
     */
    initialize() {
        let handout = this.findDatabaseHandout();
        
        if (!handout) {
            handout = this.createDatabaseHandout();
            this.log(`Created new ${this.config?.HANDOUT?.DATABASE || 'Item-Database'} handout.`, "success");
        } else {
            this.log(`Found existing ${this.config?.HANDOUT?.DATABASE || 'Item-Database'} handout.`, "info");
        }
        
        return handout;
    },
    
    /**
     * Find the database handout
     * @returns {Object|null} Database handout or null if not found
     */
    findDatabaseHandout() {
        const databaseName = this.config?.HANDOUT?.DATABASE || 'Item-Database';
        return findObjs({ _type: "handout", name: databaseName })[0] || null;
    },
    
    /**
     * Create new database handout with initial structure
     * @returns {Object} Created handout object
     */
    createDatabaseHandout() {
        const databaseName = this.config?.HANDOUT?.DATABASE || 'Item-Database';
        const handout = createObj("handout", { name: databaseName });
        
        // Initialize with empty database structure
        const initialData = {
            type: "item_database",
            version: this.config?.VERSION || '1.0.0',
            items: {}
        };
        
        // Initialize categories and rarities from config
        const rarities = this.config?.ITEM?.RARITIES || ['common', 'uncommon', 'rare', 'very rare', 'legendary'];
        const categories = this.config?.ITEM?.CATEGORIES || ['weapons', 'equipment', 'potions'];
        
        rarities.forEach(rarity => {
            initialData.items[rarity] = {};
            categories.forEach(category => {
                initialData.items[rarity][category] = [];
            });
        });
        
        handout.set("gmnotes", JSON.stringify(initialData, null, 2));
        return handout;
    },
    
    /**
     * Process and validate item data
     * @param {Object} item - Raw item data
     * @returns {Object} Processed item data
     */
    processItem(item) {
        // Ensure required fields
        if (!item.id) {
            item.id = item.name ? 
                item.name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '') : 
                `item_${Date.now()}`;
        }
        
        // Ensure price is valid
        if (!item.price || Object.keys(item.price).length === 0) {
            item.price = { gp: 0 };
        }
        
        // Ensure rarity is valid
        const validRarities = this.config?.ITEM?.RARITIES || ['common'];
        if (!item.rarity || !validRarities.includes(item.rarity)) {
            item.rarity = this.config?.ITEM?.DEFAULT_RARITY || 'common';
        }
        
        // Ensure category is valid (case-insensitive check)
        const validCategories = this.config?.ITEM?.CATEGORIES || ['equipment'];
        if (!item.category) {
            item.category = this.config?.ITEM?.DEFAULT_CATEGORY || 'equipment';
        } else {
            const lowerCaseItemCategory = item.category.toLowerCase();
            const foundCategory = validCategories.find(
                cfgCategory => cfgCategory.toLowerCase() === lowerCaseItemCategory
            );
            if (foundCategory) {
                item.category = foundCategory; // Assign canonical name
            } else {
                item.category = this.config?.ITEM?.DEFAULT_CATEGORY || 'equipment';
            }
        }
        
        return item;
    },
    
    // ===================================================================
    // ITEM CRUD OPERATIONS
    // ===================================================================
    
    /**
     * List items by category and rarity
     * @param {string} category - Category filter ('all' for all categories)
     * @param {string} rarity - Rarity filter ('all' for all rarities)
     * @returns {Promise<Array>} Promise resolving to array of items
     */
    listItems(category, rarity) {
        const handout = this.findDatabaseHandout();
        
        if (!handout) {
            this.log("Item database not found! Initialize it first.", "error");
            return Promise.resolve([]);
        }
        
        return new Promise((resolve, reject) => {
            handout.get("gmnotes", (notes) => {
                try {
                    const cleanNotes = this.cleanHandoutNotes(notes);
                    const data = JSON.parse(cleanNotes);
                    
                    if (!data || !data.items) {
                        this.log("Invalid database format!", "error");
                        resolve([]);
                        return;
                    }
                    
                    // Normalize inputs
                    const effectiveCategory = (category && category.toLowerCase() !== 'all') ? category.toLowerCase() : 'all';
                    const effectiveRarity = (rarity && rarity.toLowerCase() !== 'all') ? rarity.toLowerCase() : 'all';
                    
                    this.log(`listItems lookup: category='${effectiveCategory}', rarity='${effectiveRarity}'`, 'debug');
                    
                    let items = [];
                    
                    if (effectiveCategory === "all" && effectiveRarity === "all") {
                        // Get all items
                        Object.keys(data.items).forEach(rar => {
                            if (data.items[rar]) {
                                Object.keys(data.items[rar]).forEach(cat => {
                                    if (data.items[rar][cat]) {
                                        items = items.concat(data.items[rar][cat]);
                                    }
                                });
                            }
                        });
                    } else if (effectiveCategory === "all") {
                        // Filter by rarity only
                        if (data.items[effectiveRarity]) {
                            Object.keys(data.items[effectiveRarity]).forEach(cat => {
                                if (data.items[effectiveRarity][cat]) {
                                    items = items.concat(data.items[effectiveRarity][cat]);
                                }
                            });
                        }
                    } else if (effectiveRarity === "all") {
                        // Filter by category only
                        const validCategories = this.config?.ITEM?.CATEGORIES || [];
                        const canonicalCategory = validCategories.find(c => c.toLowerCase() === effectiveCategory);
                        
                        if (canonicalCategory) {
                            Object.keys(data.items).forEach(rar => {
                                if (data.items[rar] && data.items[rar][canonicalCategory]) {
                                    items = items.concat(data.items[rar][canonicalCategory]);
                                }
                            });
                        } else if (effectiveCategory !== "all") {
                            this.log(`Unknown category requested: ${category}`, "warn");
                        }
                    } else {
                        // Filter by specific category and rarity
                        const validCategories = this.config?.ITEM?.CATEGORIES || [];
                        const canonicalCategory = validCategories.find(c => c.toLowerCase() === effectiveCategory);
                        
                        if (canonicalCategory) {
                            if (data.items[effectiveRarity] && data.items[effectiveRarity][canonicalCategory]) {
                                items = data.items[effectiveRarity][canonicalCategory] || [];
                            }
                        } else if (effectiveCategory !== "all") {
                            this.log(`Unknown category requested: ${category}`, "warn");
                        }
                    }
                    
                    // Ensure items is always an array
                    if (!Array.isArray(items)) {
                        items = [];
                    }
                    
                    this.log(`Found ${items.length} items matching criteria`, 'info');
                    resolve(items);
                    
                } catch (error) {
                    this.log(`Error parsing database: ${error.message}`, "error");
                    reject(new Error(`Error parsing database: ${error.message}`));
                }
            });
        });
    },
    
    /**
     * Batch import multiple items
     * @param {Array} items - Array of items to import
     * @returns {Promise<Object>} Promise resolving to import results
     */
    batchImport(items) {
        const handout = this.findDatabaseHandout();
        
        if (!handout) {
            this.log("Item-Database handout not found!", "error");
            return Promise.reject(new Error("Database not initialized"));
        }
        
        return new Promise((resolve, reject) => {
            handout.get("gmnotes", (notes) => {
                try {
                    const cleanNotes = this.cleanHandoutNotes(notes) || '{"items":{}}';
                    let data;
                    
                    try {
                        data = JSON.parse(cleanNotes);
                    } catch (parseError) {
                        data = { items: {} };
                    }
                    
                    if (!data.items) {
                        data.items = {};
                    }
                    
                    const results = {
                        success: 0,
                        failed: 0,
                        skipped: 0,
                        errors: []
                    };
                    
                    // Process each item
                    for (let item of items) {
                        try {
                            item = this.processItem(item);
                            
                            if (!item.rarity || !item.category) {
                                results.failed++;
                                results.errors.push(`Missing rarity or category for item: ${item.name || 'Unknown'}`);
                                continue;
                            }
                            
                            // Ensure category exists for rarity
                            if (!data.items[item.rarity]) {
                                data.items[item.rarity] = {};
                            }
                            if (!data.items[item.rarity][item.category]) {
                                data.items[item.rarity][item.category] = [];
                            }
                            
                            // Check for duplicates
                            const isDuplicate = data.items[item.rarity][item.category].some(
                                existingItem => existingItem.id === item.id
                            );
                            
                            if (isDuplicate) {
                                results.skipped++;
                                continue;
                            }
                            
                            // Add item
                            data.items[item.rarity][item.category].push(item);
                            results.success++;
                            
                        } catch (itemError) {
                            results.failed++;
                            results.errors.push(`Error processing item ${item.name || 'Unknown'}: ${itemError.message}`);
                        }
                    }
                    
                    // Save updated database
                    handout.get("gmnotes", (currentNotes) => {
                        const currentData = JSON.parse(this.cleanHandoutNotes(currentNotes));
                        const updatedData = { ...currentData, items: data.items };
                        handout.set("gmnotes", JSON.stringify(updatedData, null, 2));
                        resolve(results);
                    });
                    
                } catch (error) {
                    this.log(`Error in batch import: ${error.message}`, "error");
                    reject(error);
                }
            });
        });
    },
    
    /**
     * Remove item from database and all shops
     * @param {string} itemId - Item ID to remove
     * @returns {Promise<Object>} Promise resolving to removal results
     */
    removeItem(itemId) {
        return new Promise((resolve, reject) => {
            const dbHandout = this.findDatabaseHandout();
            if (!dbHandout) {
                reject(new Error("Item database not found!"));
                return;
            }
            
            let removedItemName = null;
            
            // Step 1: Remove from database
            dbHandout.get("gmnotes", (notes) => {
                try {
                    const cleanNotes = this.cleanHandoutNotes(notes);
                    let data = JSON.parse(cleanNotes);
                    let itemFound = false;
                    let removedItem = null;
                    
                    // Search through all rarities and categories
                    Object.keys(data.items).forEach(rarity => {
                        Object.keys(data.items[rarity]).forEach(category => {
                            if (Array.isArray(data.items[rarity][category])) {
                                const index = data.items[rarity][category].findIndex(item => item.id === itemId);
                                if (index !== -1) {
                                    removedItem = data.items[rarity][category][index];
                                    data.items[rarity][category].splice(index, 1);
                                    itemFound = true;
                                }
                            }
                        });
                    });
                    
                    if (itemFound) {
                        removedItemName = removedItem.name;
                        dbHandout.set("gmnotes", JSON.stringify(data, null, 2));
                        this.log(`Removed ${removedItemName} from the database.`, "info");
                        
                        // Step 2: Remove from all shops
                        this.removeItemFromShops(itemId, removedItemName).then((shopsUpdated) => {
                            resolve({
                                success: true,
                                itemName: removedItemName,
                                shopsUpdated: shopsUpdated
                            });
                        }).catch(reject);
                        
                    } else {
                        reject(new Error("Item not found in database"));
                    }
                    
                } catch (error) {
                    this.log(`Error removing item from database: ${error.message}`, "error");
                    reject(error);
                }
            });
        });
    },
    
    /**
     * Update existing item in database
     * @param {Object} item - Updated item data
     * @returns {Promise<boolean>} Promise resolving to success status
     */
    updateItem(item) {
        return new Promise((resolve, reject) => {
            const dbHandout = this.findDatabaseHandout();
            if (!dbHandout) {
                reject(new Error("Item database not found!"));
                return;
            }
            
            dbHandout.get("gmnotes", (notes) => {
                try {
                    const cleanNotes = this.cleanHandoutNotes(notes);
                    let data = JSON.parse(cleanNotes);
                    let itemFound = false;
                    
                    // Search through all rarities and categories
                    Object.keys(data.items).forEach(rarity => {
                        Object.keys(data.items[rarity]).forEach(category => {
                            if (Array.isArray(data.items[rarity][category])) {
                                const index = data.items[rarity][category].findIndex(i => i.id === item.id);
                                if (index !== -1) {
                                    data.items[rarity][category][index] = item;
                                    itemFound = true;
                                }
                            }
                        });
                    });
                    
                    if (itemFound) {
                        dbHandout.set("gmnotes", JSON.stringify(data, null, 2));
                        this.log(`Updated ${item.name} in the database.`, "info");
                        resolve(true);
                    } else {
                        reject(new Error("Item not found in database"));
                    }
                    
                } catch (error) {
                    this.log(`Error updating item in database: ${error.message}`, "error");
                    reject(error);
                }
            });
        });
    },
    
    // ===================================================================
    // SHOP DATA OPERATIONS
    // ===================================================================
    
    /**
     * Remove item from all shop inventories
     * @param {string} itemId - Item ID to remove
     * @param {string} itemName - Item name for logging
     * @returns {Promise<number>} Promise resolving to number of shops updated
     */
    removeItemFromShops(itemId, itemName) {
        return new Promise((resolve) => {
            const shopPrefix = this.config?.HANDOUT?.SHOP_PREFIX || 'Shop:';
            
            // Find all handouts
            const allHandouts = findObjs({ _type: "handout" });
            this.log(`Found ${allHandouts.length} total handouts.`, 'debug');
            
            // Filter for shop handouts
            const shopHandouts = allHandouts.filter(h => {
                const name = h.get('name');
                return name && name.startsWith(shopPrefix);
            });
            
            this.log(`Found ${shopHandouts.length} shop handouts.`, 'debug');
            
            if (shopHandouts.length === 0) {
                resolve(0);
                return;
            }
            
            const shopUpdatePromises = shopHandouts.map(shopHandout => {
                return new Promise((resolveShop) => {
                    shopHandout.get("gmnotes", (shopNotes) => {
                        try {
                            const cleanShopNotes = this.cleanHandoutNotes(shopNotes);
                            if (!cleanShopNotes) {
                                resolveShop(false);
                                return;
                            }
                            
                            const shopData = JSON.parse(cleanShopNotes);
                            
                            // Validate shop structure
                            if (!shopData || shopData.type !== 'shop' || !shopData.inventory) {
                                resolveShop(false);
                                return;
                            }
                            
                            let shopModified = false;
                            
                            // Remove item from all categories
                            for (const category in shopData.inventory) {
                                if (Array.isArray(shopData.inventory[category])) {
                                    const initialLength = shopData.inventory[category].length;
                                    shopData.inventory[category] = shopData.inventory[category].filter(item => item.id !== itemId);
                                    
                                    if (shopData.inventory[category].length < initialLength) {
                                        shopModified = true;
                                    }
                                }
                            }
                            
                            if (shopModified) {
                                shopHandout.set("gmnotes", JSON.stringify(shopData, null, 2));
                                this.log(`Removed ${itemName} from shop: ${shopHandout.get('name')}`, 'debug');
                                resolveShop(true);
                            } else {
                                resolveShop(false);
                            }
                            
                        } catch (shopError) {
                            this.log(`Error processing shop ${shopHandout.get('name')}: ${shopError.message}`, "error");
                            resolveShop(false);
                        }
                    });
                });
            });
            
            Promise.all(shopUpdatePromises).then(results => {
                const shopsUpdated = results.filter(updated => updated).length;
                resolve(shopsUpdated);
            });
        });
    },
    
    // ===================================================================
    // CHARACTER OPERATIONS
    // ===================================================================
    
    /**
     * Set character currency with multi-sheet support
     * @param {string} characterId - Character ID
     * @param {Object} newCurrency - New currency values
     * @returns {boolean} Success status
     */
    setCharacterCurrency(characterId, newCurrency) {
        const char = getObj('character', characterId);
        if (!char) {
            this.log(`Character not found for ID: ${characterId}`, 'error');
            return false;
        }
        
        const charName = char.get('name');
        this.log(`Setting currency for ${charName}: ${JSON.stringify(newCurrency)}`, 'debug');
        
        let attributeUpdated = false;
        
        // Helper to set attribute value
        const setAttribute = (attrName, value) => {
            let attr = findObjs({ _type: 'attribute', _characterid: characterId, name: attrName })[0];
            if (attr) {
                attr.set('current', value);
                this.log(`Updated attribute ${attrName} to ${value}`, 'debug');
                attributeUpdated = true;
                return true;
            } else {
                this.log(`Attribute ${attrName} not found`, 'debug');
                return false;
            }
        };
        
        // Try Standard D&D 5e Sheet Attributes
        const standardAttrs = ['pp', 'gp', 'ep', 'sp', 'cp'];
        let foundStandard = false;
        
        standardAttrs.forEach(coin => {
            const attrExists = findObjs({ _type: 'attribute', _characterid: characterId, name: coin })[0];
            if (attrExists) {
                foundStandard = true;
                setAttribute(coin, newCurrency[coin] || 0);
            }
        });
        
        if (foundStandard && attributeUpdated) {
            this.log(`Updated standard attributes for ${charName}`, 'debug');
            return true;
        }
        
        // Try Beacon Sheet Attributes
        const beaconAttrs = {
            pp: 'money_pp',
            gp: 'money_gp',
            ep: 'money_ep',
            sp: 'money_sp',
            cp: 'money_cp'
        };
        
        let foundBeacon = false;
        attributeUpdated = false;
        
        Object.entries(beaconAttrs).forEach(([coin, attrName]) => {
            const attrExists = findObjs({ _type: 'attribute', _characterid: characterId, name: attrName })[0];
            if (attrExists) {
                foundBeacon = true;
                setAttribute(attrName, newCurrency[coin] || 0);
            }
        });
        
        if (foundBeacon && attributeUpdated) {
            this.log(`Updated Beacon attributes for ${charName}`, 'debug');
            return true;
        }
        
        // Try Beacon Store Attribute (fallback)
        const storeAttr = findObjs({
            _type: 'attribute',
            _characterid: characterId,
            name: 'store'
        })[0];
        
        if (storeAttr) {
            this.log(`Attempting fallback update via Beacon 'store' attribute for ${charName}`, 'debug');
            try {
                let storeData = storeAttr.get('current');
                
                if (typeof storeData === 'string') {
                    if (storeData.trim() === '') {
                        throw new Error("Store attribute is empty");
                    }
                    storeData = JSON.parse(storeData || '{}');
                }
                
                if (typeof storeData === 'object' && storeData !== null) {
                    let storeUpdated = false;
                    
                    const updateCurrencyInStore = (obj) => {
                        if (!obj) return;
                        if (Array.isArray(obj)) {
                            obj.forEach(item => updateCurrencyInStore(item));
                        } else if (typeof obj === 'object') {
                            if (obj.name && obj.type === "Currency") {
                                const coinName = obj.name.toLowerCase();
                                const newValue = newCurrency[coinName.substring(0, 2)] || 0;
                                if (obj.value !== newValue) {
                                    obj.value = newValue;
                                    storeUpdated = true;
                                    this.log(`Updated ${obj.name} in store to ${newValue}`, 'debug');
                                }
                            }
                            Object.values(obj).forEach(value => {
                                if (typeof value === 'object') {
                                    updateCurrencyInStore(value);
                                }
                            });
                        }
                    };
                    
                    updateCurrencyInStore(storeData);
                    
                    if (storeUpdated) {
                        storeAttr.set('current', JSON.stringify(storeData));
                        this.log(`Updated currency within Beacon 'store' attribute for ${charName}`, 'debug');
                        return true;
                    }
                }
            } catch (e) {
                this.log(`Error updating Beacon 'store' attribute for ${charName}: ${e.message}`, 'warn');
            }
        }
        
        this.log(`Could not find any known currency attributes to update for ${charName}`, 'error');
        return false;
    },
    
    /**
     * Get character currency with multi-sheet support
     * @param {string} characterId - Character ID
     * @returns {Object} Currency object
     */
    getCharacterCurrency(characterId) {
        const char = getObj('character', characterId);
        if (!char) {
            this.log(`Character not found for ID: ${characterId}`, 'error');
            return { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 };
        }
        
        const currency = { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 };
        
        // Try standard attributes first
        const standardAttrs = ['cp', 'sp', 'ep', 'gp', 'pp'];
        let foundStandard = false;
        
        standardAttrs.forEach(coin => {
            const attr = findObjs({ _type: 'attribute', _characterid: characterId, name: coin })[0];
            if (attr) {
                foundStandard = true;
                currency[coin] = parseInt(attr.get('current')) || 0;
            }
        });
        
        if (foundStandard) {
            return currency;
        }
        
        // Try Beacon attributes
        const beaconAttrs = {
            cp: 'money_cp',
            sp: 'money_sp',
            ep: 'money_ep',
            gp: 'money_gp',
            pp: 'money_pp'
        };
        
        let foundBeacon = false;
        Object.entries(beaconAttrs).forEach(([coin, attrName]) => {
            const attr = findObjs({ _type: 'attribute', _characterid: characterId, name: attrName })[0];
            if (attr) {
                foundBeacon = true;
                currency[coin] = parseInt(attr.get('current')) || 0;
            }
        });
        
        if (foundBeacon) {
            return currency;
        }
        
        this.log(`No currency attributes found for character ${char.get('name')}`, 'warn');
        return currency;
    },
    
    // ===================================================================
    // UTILITY METHODS
    // ===================================================================
    
    /**
     * Clean handout notes (remove HTML entities)
     * @param {string} notes - Raw handout notes
     * @returns {string} Cleaned notes
     */
    cleanHandoutNotes(notes) {
        if (!notes) return '';
        
        // Decode HTML entities
        return notes
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&amp;/g, '&');
    },
    
    /**
     * Parse item text for batch import
     * @param {string} text - Raw item text
     * @returns {Array} Parsed items array
     */
    parseItemText(text) {
        const items = [];
        const lines = text.split('\n');
        let currentItem = null;
        
        for (let line of lines) {
            line = line.trim();
            if (!line) continue;
            
            // Check if this line starts a new item (no dash prefix)
            if (!line.startsWith('-') && !line.startsWith('‚Ä¢')) {
                // Save previous item if exists
                if (currentItem && currentItem.name) {
                    items.push(currentItem);
                }
                
                // Start new item
                currentItem = {
                    name: line,
                    price: { gp: 0 }
                };
            } else if (currentItem) {
                // Parse property line
                const cleanLine = line.replace(/^[-‚Ä¢]\s*/, '');
                const colonIndex = cleanLine.indexOf(':');
                
                if (colonIndex > 0) {
                    const key = cleanLine.substring(0, colonIndex).trim().toLowerCase();
                    const value = cleanLine.substring(colonIndex + 1).trim();
                    
                    this.parseItemProperty(currentItem, key, value);
                }
            }
        }
        
        // Don't forget the last item
        if (currentItem && currentItem.name) {
            items.push(currentItem);
        }
        
        return items;
    },
    
    /**
     * Parse individual item property
     * @param {Object} item - Item being parsed
     * @param {string} key - Property key
     * @param {string} value - Property value
     */
    parseItemProperty(item, key, value) {
        switch (key) {
            case 'price':
                const priceMatch = value.match(/(\d+(?:\.\d+)?)\s*(gp|sp|cp|ep|pp)/i);
                if (priceMatch) {
                    const amount = parseFloat(priceMatch[1]);
                    const currency = priceMatch[2].toLowerCase();
                    item.price = { [currency]: amount };
                }
                break;
                
            case 'weight':
                item.weight = parseFloat(value) || 0;
                break;
                
            case 'properties':
                item.properties = value.split(',').map(p => p.trim());
                break;
                
            case 'attunement':
                item.attunement = value.toLowerCase().includes('yes');
                break;
                
            case 'consumable':
                item.consumable = value.toLowerCase().includes('yes');
                break;
                
            default:
                item[key] = value;
        }
    },
    
    /**
     * Get all shop handouts
     * @returns {Array} Array of shop handout objects
     */
    getShopHandouts() {
        const shopPrefix = this.config?.HANDOUT?.SHOP_PREFIX || 'Shop:';
        const allHandouts = findObjs({ _type: "handout" });
        
        return allHandouts.filter(h => {
            const name = h.get('name');
            return name && name.startsWith(shopPrefix);
        });
    },
    
    /**
     * Create or update shop handout
     * @param {Object} shopData - Shop data to save
     * @param {string} shopName - Shop name
     * @returns {Object} Shop handout object
     */
    saveShopData(shopData, shopName) {
        const shopPrefix = this.config?.HANDOUT?.SHOP_PREFIX || 'Shop:';
        const handoutName = `${shopPrefix} ${shopName}`;
        
        let handout = findObjs({
            _type: "handout",
            name: handoutName
        })[0];
        
        if (!handout) {
            handout = createObj("handout", {
                name: handoutName,
                archived: false
            });
        }
        
        handout.set("gmnotes", JSON.stringify(shopData, null, 2));
        return handout;
    },
    
    /**
     * Load shop data from handout
     * @param {string} shopName - Shop name
     * @returns {Object|null} Shop data or null if not found
     */
    loadShopData(shopName) {
        const shopPrefix = this.config?.HANDOUT?.SHOP_PREFIX || 'Shop:';
        const handoutName = `${shopPrefix} ${shopName}`;
        
        const handout = findObjs({
            _type: "handout",
            name: handoutName
        })[0];
        
        if (!handout) {
            return null;
        }
        
        try {
            const notes = handout.get("gmnotes");
            const cleanNotes = this.cleanHandoutNotes(notes);
            return JSON.parse(cleanNotes);
        } catch (error) {
            this.log(`Error loading shop data for ${shopName}: ${error.message}`, 'error');
            return null;
        }
    },
    
    /**
     * Validate database structure
     * @returns {Object} Validation results
     */
    validateDatabase() {
        const handout = this.findDatabaseHandout();
        if (!handout) {
            return { valid: false, error: "Database handout not found" };
        }
        
        try {
            const notes = handout.get("gmnotes");
            const cleanNotes = this.cleanHandoutNotes(notes);
            const data = JSON.parse(cleanNotes);
            
            if (!data.items) {
                return { valid: false, error: "Missing items structure" };
            }
            
            let totalItems = 0;
            const categories = new Set();
            const rarities = new Set();
            
            Object.keys(data.items).forEach(rarity => {
                rarities.add(rarity);
                if (data.items[rarity]) {
                    Object.keys(data.items[rarity]).forEach(category => {
                        categories.add(category);
                        if (Array.isArray(data.items[rarity][category])) {
                            totalItems += data.items[rarity][category].length;
                        }
                    });
                }
            });
            
            return {
                valid: true,
                totalItems,
                categories: Array.from(categories),
                rarities: Array.from(rarities),
                version: data.version || 'Unknown'
            };
            
        } catch (error) {
            return { valid: false, error: `Parse error: ${error.message}` };
        }
    },
    
    // Helper methods
    log(message, type = 'info') {
        const prefix = this.config?.LOGGING?.PREFIX?.[type] || 'üìú';
        log(`${prefix} DatabaseManager: ${message}`);
    }
};

// Export for Roll20 environment
// Removed: Module export
    // Removed: Module export
// Roll20 environment:
    this.DatabaseManager = DatabaseManager;
}

// END MODULE: DatabaseManager.js


// ===================================================================
// MODULE 8/8: index.js
// ===================================================================

/**
 * ShopSystem Modules Index
 * 
 * This index file exports all the modular components of the Shop System
 * for use in the main Live-SYS-ShopSystem.js file.
 * 
 * Usage:
 * - Include this at the top of Live-SYS-ShopSystem.js
 * - Replace existing inline functionality with module calls
 * 
 * Refactoring Progress:
 * [‚úì] Foundation setup
 * [‚úì] Phase 1: Core Utilities (CurrencyManager, ShopConfig, MenuBuilder)
 * [‚úì] Phase 2: Business Logic (BasketManager, ReceiptGenerator, StockManager)
 * [ ] Phase 3: Data Management (DatabaseManager)
 * [ ] Phase 4: Integration & Optimization
 */

// Core Utilities (Phase 1)
const ShopConfig = typeof ShopConfig !== 'undefined' ? ShopConfig : null;
const CurrencyManager = typeof CurrencyManager !== 'undefined' ? CurrencyManager : null;
const MenuBuilder = typeof MenuBuilder !== 'undefined' ? MenuBuilder : null;

// Business Logic (Phase 2)
const BasketManager = typeof BasketManager !== 'undefined' ? BasketManager : null;
const ReceiptGenerator = typeof ReceiptGenerator !== 'undefined' ? ReceiptGenerator : null;
const StockManager = typeof StockManager !== 'undefined' ? StockManager : null;

// Data Management (Phase 3 - Future)
const DatabaseManager = typeof DatabaseManager !== 'undefined' ? DatabaseManager : null;

// Module registry and initialization
const ShopSystemModules = {
    // Core utilities
    config: null,
    currency: null,
    menu: null,
    
    // Business logic
    basket: null,
    receipt: null,
    stock: null,
    
    // Data management
    database: null,
    
    // Initialization status
    initialized: false,
    
    /**
     * Initialize all available modules
     * @returns {Object} Initialization results
     */
    init() {
        const results = {
            success: true,
            initialized: [],
            failed: [],
            warnings: []
        };
        
        try {
            // Phase 1: Core Utilities
            if (ShopConfig) {
                this.config = ShopConfig;
                results.initialized.push('ShopConfig');
            } else {
                results.failed.push('ShopConfig');
                results.success = false;
            }
            
            if (CurrencyManager) {
                this.currency = CurrencyManager.init(this.config);
                results.initialized.push('CurrencyManager');
            } else {
                results.failed.push('CurrencyManager');
                results.success = false;
            }
            
            if (MenuBuilder) {
                this.menu = MenuBuilder.init(this.config);
                results.initialized.push('MenuBuilder');
            } else {
                results.failed.push('MenuBuilder');
                results.success = false;
            }
            
            // Phase 2: Business Logic
            if (BasketManager) {
                this.basket = BasketManager.init(this.config);
                results.initialized.push('BasketManager');
            } else {
                results.failed.push('BasketManager');
                results.success = false;
            }
            
            if (ReceiptGenerator) {
                this.receipt = ReceiptGenerator.init(this.config);
                results.initialized.push('ReceiptGenerator');
            } else {
                results.failed.push('ReceiptGenerator');
                results.success = false;
            }
            
            if (StockManager) {
                this.stock = StockManager.init(this.config);
                results.initialized.push('StockManager');
            } else {
                results.failed.push('StockManager');
                results.success = false;
            }
            
            // Phase 3: Data Management (Future)
            if (DatabaseManager) {
                this.database = DatabaseManager.init(this.config);
                results.initialized.push('DatabaseManager');
            } else {
                results.warnings.push('DatabaseManager not available (Phase 3)');
            }
            
            this.initialized = results.success;
            
            if (results.success) {
                log("üéâ All ShopSystem modules initialized successfully!");
                log(`‚úÖ Initialized: ${results.initialized.join(', ')}`);
            } else {
                log("‚ö†Ô∏è ShopSystem module initialization completed with errors");
                log(`‚úÖ Initialized: ${results.initialized.join(', ')}`);
                log(`‚ùå Failed: ${results.failed.join(', ')}`);
            }
            
            if (results.warnings.length > 0) {
                log(`‚ö†Ô∏è Warnings: ${results.warnings.join(', ')}`);
            }
            
        } catch (error) {
            results.success = false;
            results.failed.push(`Initialization error: ${error.message}`);
            log(`‚ùå Fatal error during module initialization: ${error.message}`);
        }
        
        return results;
    },
    
    /**
     * Get module status summary
     * @returns {Object} Status information
     */
    getStatus() {
        return {
            initialized: this.initialized,
            availableModules: {
                config: !!this.config,
                currency: !!this.currency,
                menu: !!this.menu,
                basket: !!this.basket,
                receipt: !!this.receipt,
                stock: !!this.stock,
                database: !!this.database
            },
            moduleCount: Object.values(this).filter(module => 
                module && typeof module === 'object' && typeof module.init === 'function'
            ).length
        };
    },
    
    /**
     * Verify all required modules are available
     * @returns {boolean} Whether all required modules are available
     */
    verifyModules() {
        const required = ['config', 'currency', 'menu', 'basket', 'receipt', 'stock'];
        const missing = required.filter(module => !this[module]);
        
        if (missing.length > 0) {
            log(`‚ùå Missing required modules: ${missing.join(', ')}`);
            return false;
        }
        
        return true;
    },
    
    /**
     * Reinitialize modules after updates
     * @returns {Object} Reinitialization results
     */
    reinit() {
        log("üîÑ Reinitializing ShopSystem modules...");
        this.initialized = false;
        return this.init();
    }
};

// Auto-initialize if in Roll20 environment
if (typeof state !== 'undefined' && typeof log !== 'undefined') {
    // Wait for all modules to be loaded
    setTimeout(() => {
        ShopSystemModules.init();
    }, 100);
}

// Export for different environments
// Removed: Module export
    // Node.js environment
    // Removed: Module export
// Removed: Exports
    // CommonJS environment
    // Removed: Export assignment
// Roll20 environment:
    // Roll20/Browser environment
    this.ShopSystemModules = ShopSystemModules;
}

// END MODULE: index.js


// ===================================================================
// MODULE INITIALIZATION
// ===================================================================

// Initialize all ShopSystem modules
if (typeof ShopSystemModules !== 'undefined') {
    // Auto-initialize modules when Roll20 is ready
    on('ready', function() {
        const initResults = ShopSystemModules.init();
        
        if (initResults.success) {
            log('üéâ ShopSystem modular build loaded successfully!');
            log(`‚úÖ Modules initialized: ${initResults.initialized.length}`);
        } else {
            log('‚ö†Ô∏è ShopSystem loaded with module errors');
            log(`‚ùå Failed modules: ${initResults.failed.join(', ')}`);
        }
        
        // Log build information
        log('üì¶ ShopSystem Build Info:');
        log('   Version: Built with modular system v2.0');
        log(`   Modules: ${initResults.initialized.join(', ')}`);
        log('   Mode: Production');
    });
} else {
    log('‚ùå ShopSystemModules not found - check module loading');
}


// ===================================================================
// SHOPSYSTEM MODULES - END
// ===================================================================

// Build complete - ready for Roll20 deployment